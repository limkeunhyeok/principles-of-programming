# Chapter 6 기법-프로그래머의 도구 상자

## 6.1 예광탄

### 최종 형태에도 남는 골격 코드

- 예광탄이란 빛을 발산함으로써 탄도의 궤적을 알 수 있게끔 만들어진 탄환을 말한다.
- 프로그래밍에서의 예광탄이란 우선적으로 검증하고 싶은 부분을 선행적으로 프로그래밍하는 것이다.

### 암흑 속에서 길을 비춘다

- 소프트웨어 개발에서 예광탄과 똑같은 효과를 내려면, 소프트웨어의 최종 형태에 대한 결정을 신속하고 눈에 보이는 형태로 반복해서 제시할 수 있어야 한다.
- 예광탄과 같은 접근법의 장점
  - 사용자로부터 피드백을 얻을 수 있다.
  - 프로그래머가 활약할 수 있는 무대를 조기에 정비할 수 있다.
  - 디버깅과 테스트를 빠르고 정확하게 할 수 있다.
  - 데모 가능한 소프트웨어를 확보할 수 있다.
  - 진척 상태가 명확해진다.

### 최초 단계에 동작하는 토대를 만든다

- 토대가 되는 코드는 최소한으로 머물게 한다.
  - 소프트웨어 최종 형태에서 골격의 일부가 되는 코드로 작성해야 한다.
- 토대가 되는 코드에 덧붙여 갈 때 중요한 점은 목표와 어긋남이 있는지 확인하는 것이다.

### 프로토타입과의 차이

#### 프로토타입

- 프로토타입은 소프트웨어의 컨셉이나 최종 형태에 관한 이해를 검증하기 위한 것이다.
- 컨섭 확인이 끝난 뒤에는 작성한 것을 전부 날려 버리고, 얻은 정보를 사용해서 다시 한번 올바른 형태로 재구축한다.

#### 예광탄

- 예광탄은 소프트웨어 전체가 어떤 식으로 연계되는지를 명확히 한다.
- 프로그래머에게는 앞으로도 계속 사용할 아키텍처상의 골격을 제공하고, 사용자에게는 어떤 사용성이 있는지를 제시한다.

### 프로토타입은 견본품이자 시제품

- 프로토타입의 본질은 학습인데, 크게 2가지 측면이 있다.

1. 견본품으로서의 프로토타입
  - 이는 사용자의 요구사항을 정확하게 파악하는 것이 목적이다.
2. 시제품으로서의 프로토타입
  - 이는 개발 방법을 검토하는 것이 목적이다.

## 6.2 계약에 의한 설계

### 호출하는 쪽과 호출받는 쪽의 약속

- 각각의 함수는 뭔가의 작업을 수행하는 것이며, 뭔가를 개시하기 전에는 그 세계의 상태에 관해 뭔가를 상정하고, 종료 시에 그 세계의 상태에 관해 뭔가를 확약할 수 있을 것이다.
  - 이때의 상정을 사전 조건이라 부르며, 이는 함수를 호출하는 쪽이 지켜야 할 계약이다.
  - 확약을 사후 조건이라고 부르며, 이는 함수가 지켜야 할 계약이다.
- 함수와 함수를 호출하는 쪽이 서로 계약을 맺고 있다고 간주하고 프로그래밍하는 것을 가리켜 계약에 의한 설계라고 한다.

### 착오의 조기 발견

- 계약을 의식하고 제대로 지킴으로써 다음과 같은 장점을 얻을 수 있다.
  - 코드가 올바르다는 것을 보증할 수 있다. 올바른 코드란 요구되는 것 이상도 이하도 수행하지 않는 코드를 뜻한다.
  - 코드를 단순하게 만들 수 있다. 사전 조건이 충족되어 있다고 가정해서 함수의 처리 코드를 작성할 수 있기 때문이다.
  - 문제를 조기에 발견하기 쉬워진다. 계약을 완수할 수 없는 뭔가가 발생했는데도 이를 놓치는 것은 장애의 시작이다. 문제 발생 시점에서 조기에 크래시를 발생시켜야 장애를 진단하기 쉬워진다.

### 주석과 단정문으로 계약

- 계약 내용을 미리 함수의 주석으로 알려둔다.
- 계약 이행의 확인을 위한 코드는 단정문(표명)으로 표현한다.

<img width="737" alt="스크린샷 2021-09-26 오후 11 23 31" src="https://user-images.githubusercontent.com/38815618/134812146-c25663ba-331a-4745-8e39-16edc422062d.png">

- 함수쪽에서는 파라미터를 조정하지 않는다.
- 함수 쪽의 단정문을 사용자 입력 확인에 사용하지 않는다.
- 함수 쪽에서는 상정은 엄격하고 확약은 관용적으로 한다.

### 클래스 불변 표명

- 객체 지향에서의 계약에 의한 설계는 함수(메소드)의 사전 조건과 사후 조건에 추가로 클래스 불변 표명이라는 계약이 있다.
  - 클래스가 클래스를 사용하는 쪽에 대해 항상 참이 된다는 것을 보증하는 조건이다.
  
### 단정문(표명)

- 코드에서 상정 외의 사항은 단정문(표명)을 통해 표현한다.
- 단정문이 참이라는 말은 모든 것이 순조롭게 실행되고 있다는 점을 의미한다.
- 단정문은 개발 중인 코드에서 모순되는 조건, 예상 외의 상태, 함수에 전달된 잘못된 값 등을 밝혀내기 위해 사용한다.
- 단정문에 넘겨주는 조건식에는 변숫값을 바꾸는 등의 부작용이 없도록 한다.
- 단정문은 배포본 소프트웨어에는 넣지 않도록 한다.

### 트래시보다는 크래시

- 코드 실행 중에 있을 수 없는 일이 발생했을 때는 재빨리 크래시, 즉 실행을 정지하는 것이 정론이다.
- 있을 수 없는 일이 발생한 시점에서 코드는 이미 실행을 계속하기가 불가능한 상태다.
- 오류를 가진 채로 어중간하게 동작하는 소프트웨어보다는, 단념하고 동작을 정지하는 소프트웨어 쪽이 손해가 적다.

## 6.3 방어적 프로그래밍

### ~지도 모르는 프로그래밍

- '이렇게 될 것이다'라고 결정짓지 말고 프로그래밍한다.
- 함수에 잘못된 데이터가 넘어왔을 때 그것이 다른 함수 탓이었다고 해도 피해를 입지 않도록 방어적인 코드를 작성해 둔다.

#### 외부 소스에서의 데이터 입력값을 확인한다(상정 내의 오류를 검출)

- 파일, 사용자 인터페이스, 네트워크, 그 밖에 외부 인터페이스로부터 데이터를 얻어 온다면 데이터가 허용 범위 내에 들어와 있다는 것을 확인한다.
- 무효한 입력을 가능한 한 조기에 검출하고 즉시 적절한 오류 처리를 수행하도록 한다.

#### 함수의 입력 파라미터값을 확인한다(상정 외의 오류를 검출)

- 다른 함수에서 전달된 함수의 입력 파라미터값을 확인한다.
- 단정문을 사용해서 파라미터를 확인하고 잘못된 값일 때는 즉시 프로그램을 정지하도록 해둔다.

### 개발과 운용의 안전 운전

#### 개발 중의 안전 운전

- 잘못된 데이터를 조기에 찾아내면 디버깅 효율이 올라간다.
- 오류를 빨리 검출하지 않으면 결함이 다른 곳에서 다른 형태로 발생하면서 기본 원인을 조사하는 데 시간을 빼앗긴다.

#### 운용 중의 안전 운전

- 잘못된 데이터에 빨리 대처함으로써 운용 중에 문제가 커지는 것을 막는다.
- 오류에 대한 대처가 불충분하면 다른 처리로 오류가 전파되어 문제가 커진다.

### 바리케이드 전략

- 바리케이드를 구축해서 피해를 봉쇄하는 방법이다.
- 코드에 바리케이드를 구축하려면 특정 인터페이스를 안전지대로의 경계로 사용한다.

### 단정문과 오류 처리의 구분

- 상정 외의 오류는 단정문으로 대응하고, 상정 내의 오류는 각각 적절한 오류 처리로 대응한다.
- 바리케이드의 외부에서 데이터에 관해 뭔가를 상정하는 것은 위험하다.
  - 바리케이드의 외부에 있는 모듈에는 오류 처리를 적용한다.
- 바리케이드의 내부에 전달된 데이터는 바리케이드를 통과하기 전에 소독이 되었을 것이다.
  - 바리케이드 내부에서 어떤 모듈이 잘못된 데이터를 검출했다면 이는 데이터 오류가 아닌 코드 오류다.

### 다양한 오류 처리 방법

#### 무해한 값을 반환한다

- 무해하다고 알려진 값이 있다면 해당 값을 반환한다.

#### 다음 데이터로 대신한다

- 일련의 데이터를 처리한다면 다음번에 유효한 데이터를 반환한다.

#### 이전과 같은 값을 반환한다

- 결과에 큰 영향이 없다면 이전과 같은 값을 반환한다.

#### 가장 가까운 유효값으로 대신한다

- 요구되는 정밀성 안에서 허용 범위 내의 근사치를 반환한다.

#### 로그에 기록한다

- 로그 파일에 경고 메시지를 기록하고 처리를 계속한다.

#### 오류를 반환한다

- 호출 계층의 상위 함수가 오류를 처리해 주기를 기대하면서 오류가 검출된 사실을 보고하는 데 머무른다.

#### 오류 처리 함수를 호출한다

- 오류 처리를 공통 오류 처리 함수로 일원화한다.

#### 오류 메시지를 표시한다

- 오류가 발생한 위치에서 오류 메시지를 표시한다.

#### 처리를 중지한다

- 오류를 검출했다면 처리를 중지한다.

#### 각 위치에서 최적인 오류 처리를 선택한다

- 어떤 오류 처리 방법을 사용할지의 판단을 오류가 발생한 부분의 설계와 구현을 담당하는 프로그래머에게 일임한다.

### 오류 처리의 정당성과 견고성

- 정당성이란 잘못된 결과를 절대로 반환하지 않는다는 것을 의미한다.
  - 부정확한 결과를 반환할 바에는 아무것도 반환하지 않는 편이 차라리 낫다는 사고방식이다.
- 견고성이란 실행을 계속할 수 있도록 온갖 수단과 방법을 다하는 것이다.
  - 부정확한 결과가 초래되더라도 실행만 계속할 수 있다면 상관없다는 사고방식이다.

### 입력 데이터를 올바른 형식으로 변환한다

- 보통 외부에서 데이터가 전달될 때 데이터를 소독한다.
- 형식이 잘못된 데이터가 잠시라도 코드에 머무르면 상황이 복잡해진다.
- 입력 데이터는 즉시 올바른 형식으로 변환하는 것이 기본이다.

### 오류 코드를 무시하지 않는다

- 오류를 무시하지 않는 것이 방어적 프로그래밍의 철칙이다.
- 함수가 오류 코드를 반환하더라도 받아들이는 쪽에서 무시할 수는 있지만, 반드시 함수의 반환값을 평가하는 습관을 들여야 한다.
- 오류가 발견되었다면 오류 번호와 오류 상세를 로그로 출력하도록 한다.

### 언어 안으로의 프로그래밍

- 언어 안에서 프로그래밍하는 프로그래머는 자기 생각을 언어가 직접 지원하는 구조에 한정해 버린다.
- 언어 안으로 프로그래밍하는 프로그래머는 어떤 생각을 표현하고 싶은지를 우선 결정한다.
- 프로그래밍 언어 안에서가 아닌 안으로 코드를 작성하도록 한다.

## 6.4 개밥 먹기

### 소프트웨어의 맛보기

- 자기가 개발한 소프트웨어는 본인이 직접 사용해 봐야 한다.
- 만드는 도중이거나 배포한지 얼마 안 되었다면 아직 다듬어져 있지 않아 완벽한 소프트웨어가 아닐 수 있다.

### 사용자의 관점을 얻는다

- 개발팀은 자신이 개발한 것에 관해서는 무의식적으로, 의도하지 않았지만 장애를 피하려는 경향이 있다.
- 사용자가 직접 사용하듯 사용하면 소프트웨어의 사용자적인 관점을 얻을 수 있다.
- 사용자가 사용하듯 사용하면 전혀 사용하지 않는 기능이나 반대로 원하는 기능을 찾을 수 있다.

### 직접 사용자처럼 사용한다

- 배포 전에 본인이 진짜 사용자가 되어 소프트웨어를 사용해 본다.
- 배포 전 소프트웨어는 품질이 나쁘므로 평소 작업에 방해가 될 위험이 있다.
- 배포 후에도 직접 소프트웨어를 계속 사용한다.

## 6.5 고무 오리

### 설명하는 디버깅

- 고무 오리는 일종의 디버깅 기법이다.
- 프로그래밍 중에 발생한 문제, 혹은 문제를 품고 있는 코드를 누군가에게 설명한다.

### 자체 해결을 촉진한다

- 남에게 문제를 설명하려면 우선 코드를 통독하고 그중에 존재하는 암묵적인 가정을 명확히 해야 한다.
- 설명 과정 중 잘못된 코드에 도달하는 시점에 설명이 되지 않는, 혹은 설명과 코드가 맞지 않는다는 사실을 깨달으면서 결함 부분을 발견할 수 있을 때가 있다.

### 무생물에게 설명

- 문제 해결이 정체되고 있다면 누군가에게 사정을 설명한다.
- 팀의 최적화를 고려한다면 이런 기법을 적용할 때 우선 '무생물을 대상으로'와 같은 규칙을 두는 것은 효과적인 운용이라 할 수 있다.

## 6.6 컨텍스트

### 문맥 대화와 문맥 사고

- 컨텍스트란 주위의 상황이나 배경을 뜻하며, 문맥이라고도 한다.

#### 코드의 읽고 쓰기에 사용

- 코드의 읽고 쓰기는 코드를 작성하는 사람과 코드를 읽는 사람과의 의사소통이다.
- 모듈명처럼 큰 묶음의 이름을 통해 여기서는 무엇에 관한 책임을 가졌는지를 명확히 제시한다.

#### 생각의 도구로 사용

- 프로그래밍은 문제를 해결하는 작업이다.
- 문제는 단독 요소를 보는 것만으로는 해결에 다다를 수 없다.
- 모든 것은 이어져 있으며 미묘하게 움직이고 있다.

### 대화나 생각을 미아로 만들지 않는다

- 어떤 것을 설명할 때 컨텍스트를 덧붙여 제시하면 뿔뿔이 흩어졌던 정보가 이어진다.
- 코드는 읽는 사람에게 무엇을 하고 있는지를 알기 쉽게 전달해야 한다.

### 컨텍스트를 제시한다

- 코드를 작성할 때는 컨텍스트를 먼저 제시하게 한다.
- 코드를 읽을 때는 컨텍스트를 파악한 다음에 내부 코드를 이해하도록 한다.
- 작업 전반에 걸쳐 컨텍스트와 동떨어진 규칙에서는 서서히 거리를 둔다.

### 컨텍스트와 작업 의뢰

- 남에게 코드 작성을 의뢰할 때도 컨텍스트라는 관점은 유효하다.

### 컨텍스트의 전도 능력

- 컨텍스트는 의사소통에 크게 기여한다.
- 표제와의 관계를 확인하면서 읽는 방식은 합리적이며, 이런 읽기 방식을 하향식 독서라고 부른다.
- 코드를 읽을 때도 책을 읽을 때와 완전히 동일하다.

### 팀은 하이 컨텍스트 지향으로

- 하이 컨텍스트란 어떤 공동체에서 배경이나 가치관 등에 많은 공통 인식이 깔린 상태를 가리킨다.
- 하이 컨텍스트 문화에서의 의사소통은 꼭 말은 하지 않아도 서로 분위기를 읽고 눈치를 살피는, 소위 척하면 척이 통용된다.
- 프로젝트팀이 하이 컨텍스트 문화라면 의사소통에 오버헤드가 없어진다.
- 새롭게 투입된 구성원은 컨텍스트가 공유되어 있지 않다.
  - 따라서 신입 구성원에 대해서는 로우 컨텍스트 문화를 차용해 올 필요가 있다.

### 코드 공통화는 컨텍스트 지향으로

- 공통화한 부분에 개별적인 변경이 필요해지는 경우가 있다.
- 공통화한 코드 부분을 수정하는 경우 영향도가 높아진다.

### 프로그래머의 컨텍스트 스위칭

- 운영체제는 여러 개의 프로세스가 하나의 CPU를 공유할 수 있어야 한다.
  - 따라서 인터럽트를 발생시켜 당시의 CPU나 메모리 상태, 즉, 컨텍스트를 회피하거나 복원하는데, 이를 컨텍스트 스위칭이라 한다.
- 프로그래밍에서 인터럽트에 의한 컨텍스트 스위칭은 매우 성질이 나쁘므로 반드시 피해야 하는 현상이다.

### 시스템 사고와 도메인 주도 설계

- 시스템이란 상호 작용하는 요소들의 모음이자, 전체로서의 기능을 갖는 것을 뜻한다.
  - 단순한 모음이 아니라 전체로서의 기능을 갖는 모임이라는 점이 특히 중요하다.
- 시스템 사고란 매사를 고찰할 때 이와 같은 시스템이라는 개념을 사용해서 대상 전체를 통일적이고 포괄적으로 파악하는 사고방식을 뜻한다.
- 도메인이란 사용자가 지식을 갖고 영향을 주며 활용하는 영역을 뜻한다.
  - 업무 영역, 사업 대상, 문제 영역이라고도 부른다.
- 도메인 주도 설계는 해당 도메인을 모델링한 결과인 도메인 모델을 소프트웨어 개발의 중심에 놓는다.

### 프로네시스와 전체 최적화

- 에피스테네: 보편적 진리이자 보편적 정당성을 지닌 지식이다.
- 테크네: 시룡적인 지식이나 기술을 응용함으로써 뭔가를 창출하고 만들어 내는 노하우다.
- 프로네시스: 에피스테네나 테크네와는 성질이 다른 지적 미덕, 즉 지식이라기보다는 실천적인 지혜라고 불러야 할 것이다.
- 소프트웨어 개발에서도 개별적이고 구체적인 상황 속에서 자신들의 능력이나 가치관에 근거하여 사용자에게 가치를 제공해야 한다.

### 관계주의와 장애 대응

- 장애가 발생했을 때는 아무래도 오류가 발생한 부분의 코드를 중심으로 보기 쉽다.
  - 코드에서만 원인을 찾을 것이 아니라 라이브러리와의 관계, 실행 환경과의 관계 등 컨텍스트 쪽으로 눈을 돌려야 한다.
