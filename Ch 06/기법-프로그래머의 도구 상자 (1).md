# Chapter 6 기법-프로그래머의 도구 상자

## 6.1 예광탄

### 최종 형태에도 남는 골격 코드

- 예광탄이란 빛을 발산함으로써 탄도의 궤적을 알 수 있게끔 만들어진 탄환을 말한다.
- 프로그래밍에서의 예광탄이란 우선적으로 검증하고 싶은 부분을 선행적으로 프로그래밍하는 것이다.

### 암흑 속에서 길을 비춘다

- 소프트웨어 개발에서 예광탄과 똑같은 효과를 내려면, 소프트웨어의 최종 형태에 대한 결정을 신속하고 눈에 보이는 형태로 반복해서 제시할 수 있어야 한다.
- 예광탄과 같은 접근법의 장점
  - 사용자로부터 피드백을 얻을 수 있다.
  - 프로그래머가 활약할 수 있는 무대를 조기에 정비할 수 있다.
  - 디버깅과 테스트를 빠르고 정확하게 할 수 있다.
  - 데모 가능한 소프트웨어를 확보할 수 있다.
  - 진척 상태가 명확해진다.

### 최초 단계에 동작하는 토대를 만든다

- 토대가 되는 코드는 최소한으로 머물게 한다.
  - 소프트웨어 최종 형태에서 골격의 일부가 되는 코드로 작성해야 한다.
- 토대가 되는 코드에 덧붙여 갈 때 중요한 점은 목표와 어긋남이 있는지 확인하는 것이다.

### 프로토타입과의 차이

#### 프로토타입

- 프로토타입은 소프트웨어의 컨셉이나 최종 형태에 관한 이해를 검증하기 위한 것이다.
- 컨섭 확인이 끝난 뒤에는 작성한 것을 전부 날려 버리고, 얻은 정보를 사용해서 다시 한번 올바른 형태로 재구축한다.

#### 예광탄

- 예광탄은 소프트웨어 전체가 어떤 식으로 연계되는지를 명확히 한다.
- 프로그래머에게는 앞으로도 계속 사용할 아키텍처상의 골격을 제공하고, 사용자에게는 어떤 사용성이 있는지를 제시한다.

### 프로토타입은 견본품이자 시제품

- 프로토타입의 본질은 학습인데, 크게 2가지 측면이 있다.

1. 견본품으로서의 프로토타입
  - 이는 사용자의 요구사항을 정확하게 파악하는 것이 목적이다.
2. 시제품으로서의 프로토타입
  - 이는 개발 방법을 검토하는 것이 목적이다.

## 6.2 계약에 의한 설계

### 호출하는 쪽과 호출받는 쪽의 약속

- 각각의 함수는 뭔가의 작업을 수행하는 것이며, 뭔가를 개시하기 전에는 그 세계의 상태에 관해 뭔가를 상정하고, 종료 시에 그 세계의 상태에 관해 뭔가를 확약할 수 있을 것이다.
  - 이때의 상정을 사전 조건이라 부르며, 이는 함수를 호출하는 쪽이 지켜야 할 계약이다.
  - 확약을 사후 조건이라고 부르며, 이는 함수가 지켜야 할 계약이다.
- 함수와 함수를 호출하는 쪽이 서로 계약을 맺고 있다고 간주하고 프로그래밍하는 것을 가리켜 계약에 의한 설계라고 한다.

### 착오의 조기 발견

- 계약을 의식하고 제대로 지킴으로써 다음과 같은 장점을 얻을 수 있다.
  - 코드가 올바르다는 것을 보증할 수 있다. 올바른 코드란 요구되는 것 이상도 이하도 수행하지 않는 코드를 뜻한다.
  - 코드를 단순하게 만들 수 있다. 사전 조건이 충족되어 있다고 가정해서 함수의 처리 코드를 작성할 수 있기 때문이다.
  - 문제를 조기에 발견하기 쉬워진다. 계약을 완수할 수 없는 뭔가가 발생했는데도 이를 놓치는 것은 장애의 시작이다. 문제 발생 시점에서 조기에 크래시를 발생시켜야 장애를 진단하기 쉬워진다.

### 주석과 단정문으로 계약

- 계약 내용을 미리 함수의 주석으로 알려둔다.
- 계약 이행의 확인을 위한 코드는 단정문(표명)으로 표현한다.

<img width="737" alt="스크린샷 2021-09-26 오후 11 23 31" src="https://user-images.githubusercontent.com/38815618/134812146-c25663ba-331a-4745-8e39-16edc422062d.png">

- 함수쪽에서는 파라미터를 조정하지 않는다.
- 함수 쪽의 단정문을 사용자 입력 확인에 사용하지 않는다.
- 함수 쪽에서는 상정은 엄격하고 확약은 관용적으로 한다.

### 클래스 불변 표명

- 객체 지향에서의 계약에 의한 설계는 함수(메소드)의 사전 조건과 사후 조건에 추가로 클래스 불변 표명이라는 계약이 있다.
  - 클래스가 클래스를 사용하는 쪽에 대해 항상 참이 된다는 것을 보증하는 조건이다.
  
### 단정문(표명)

- 코드에서 상정 외의 사항은 단정문(표명)을 통해 표현한다.
- 단정문이 참이라는 말은 모든 것이 순조롭게 실행되고 있다는 점을 의미한다.
- 단정문은 개발 중인 코드에서 모순되는 조건, 예상 외의 상태, 함수에 전달된 잘못된 값 등을 밝혀내기 위해 사용한다.
- 단정문에 넘겨주는 조건식에는 변숫값을 바꾸는 등의 부작용이 없도록 한다.
- 단정문은 배포본 소프트웨어에는 넣지 않도록 한다.

### 트래시보다는 크래시

- 코드 실행 중에 있을 수 없는 일이 발생했을 때는 재빨리 크래시, 즉 실행을 정지하는 것이 정론이다.
- 있을 수 없는 일이 발생한 시점에서 코드는 이미 실행을 계속하기가 불가능한 상태다.
- 오류를 가진 채로 어중간하게 동작하는 소프트웨어보다는, 단념하고 동작을 정지하는 소프트웨어 쪽이 손해가 적다.

## 6.3 방어적 프로그래밍

### ~지도 모르는 프로그래밍

- '이렇게 될 것이다'라고 결정짓지 말고 프로그래밍한다.
- 함수에 잘못된 데이터가 넘어왔을 때 그것이 다른 함수 탓이었다고 해도 피해를 입지 않도록 방어적인 코드를 작성해 둔다.

#### 외부 소스에서의 데이터 입력값을 확인한다(상정 내의 오류를 검출)

- 파일, 사용자 인터페이스, 네트워크, 그 밖에 외부 인터페이스로부터 데이터를 얻어 온다면 데이터가 허용 범위 내에 들어와 있다는 것을 확인한다.
- 무효한 입력을 가능한 한 조기에 검출하고 즉시 적절한 오류 처리를 수행하도록 한다.

#### 함수의 입력 파라미터값을 확인한다(상정 외의 오류를 검출)

- 다른 함수에서 전달된 함수의 입력 파라미터값을 확인한다.
- 단정문을 사용해서 파라미터를 확인하고 잘못된 값일 때는 즉시 프로그램을 정지하도록 해둔다.

### 개발과 운용의 안전 운전

#### 개발 중의 안전 운전

- 잘못된 데이터를 조기에 찾아내면 디버깅 효율이 올라간다.
- 오류를 빨리 검출하지 않으면 결함이 다른 곳에서 다른 형태로 발생하면서 기본 원인을 조사하는 데 시간을 빼앗긴다.

#### 운용 중의 안전 운전

- 잘못된 데이터에 빨리 대처함으로써 운용 중에 문제가 커지는 것을 막는다.
- 오류에 대한 대처가 불충분하면 다른 처리로 오류가 전파되어 문제가 커진다.

### 바리케이드 전략

- 바리케이드를 구축해서 피해를 봉쇄하는 방법이다.
- 코드에 바리케이드를 구축하려면 특정 인터페이스를 안전지대로의 경계로 사용한다.

### 단정문과 오류 처리의 구분

- 상정 외의 오류는 단정문으로 대응하고, 상정 내의 오류는 각각 적절한 오류 처리로 대응한다.
- 바리케이드의 외부에서 데이터에 관해 뭔가를 상정하는 것은 위험하다.
  - 바리케이드의 외부에 있는 모듈에는 오류 처리를 적용한다.
- 바리케이드의 내부에 전달된 데이터는 바리케이드를 통과하기 전에 소독이 되었을 것이다.
  - 바리케이드 내부에서 어떤 모듈이 잘못된 데이터를 검출했다면 이는 데이터 오류가 아닌 코드 오류다.

### 다양한 오류 처리 방법

#### 무해한 값을 반환한다

- 무해하다고 알려진 값이 있다면 해당 값을 반환한다.

#### 다음 데이터로 대신한다

- 일련의 데이터를 처리한다면 다음번에 유효한 데이터를 반환한다.

#### 이전과 같은 값을 반환한다

- 결과에 큰 영향이 없다면 이전과 같은 값을 반환한다.

#### 가장 가까운 유효값으로 대신한다

- 요구되는 정밀성 안에서 허용 범위 내의 근사치를 반환한다.

#### 로그에 기록한다

- 로그 파일에 경고 메시지를 기록하고 처리를 계속한다.

#### 오류를 반환한다

- 호출 계층의 상위 함수가 오류를 처리해 주기를 기대하면서 오류가 검출된 사실을 보고하는 데 머무른다.

#### 오류 처리 함수를 호출한다

- 오류 처리를 공통 오류 처리 함수로 일원화한다.

#### 오류 메시지를 표시한다

- 오류가 발생한 위치에서 오류 메시지를 표시한다.

#### 처리를 중지한다

- 오류를 검출했다면 처리를 중지한다.

#### 각 위치에서 최적인 오류 처리를 선택한다

- 어떤 오류 처리 방법을 사용할지의 판단을 오류가 발생한 부분의 설계와 구현을 담당하는 프로그래머에게 일임한다.

### 오류 처리의 정당성과 견고성

- 정당성이란 잘못된 결과를 절대로 반환하지 않는다는 것을 의미한다.
  - 부정확한 결과를 반환할 바에는 아무것도 반환하지 않는 편이 차라리 낫다는 사고방식이다.
- 견고성이란 실행을 계속할 수 있도록 온갖 수단과 방법을 다하는 것이다.
  - 부정확한 결과가 초래되더라도 실행만 계속할 수 있다면 상관없다는 사고방식이다.

### 입력 데이터를 올바른 형식으로 변환한다

- 보통 외부에서 데이터가 전달될 때 데이터를 소독한다.
- 형식이 잘못된 데이터가 잠시라도 코드에 머무르면 상황이 복잡해진다.
- 입력 데이터는 즉시 올바른 형식으로 변환하는 것이 기본이다.

### 오류 코드를 무시하지 않는다

- 오류를 무시하지 않는 것이 방어적 프로그래밍의 철칙이다.
- 함수가 오류 코드를 반환하더라도 받아들이는 쪽에서 무시할 수는 있지만, 반드시 함수의 반환값을 평가하는 습관을 들여야 한다.
- 오류가 발견되었다면 오류 번호와 오류 상세를 로그로 출력하도록 한다.

### 언어 안으로의 프로그래밍

- 언어 안에서 프로그래밍하는 프로그래머는 자기 생각을 언어가 직접 지원하는 구조에 한정해 버린다.
- 언어 안으로 프로그래밍하는 프로그래머는 어떤 생각을 표현하고 싶은지를 우선 결정한다.
- 프로그래밍 언어 안에서가 아닌 안으로 코드를 작성하도록 한다.
