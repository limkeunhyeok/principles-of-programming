# Chapter 5 습관-프로그래머의 일상

## 5.1 프로그래머의 3대 미덕

### 프로그래머는 태만, 성급, 오만할 것

#### 태만

- 전체의 노력을 줄이기 위해 수고를 아끼지 않는 기질이다.
- 나중에 모두가 편해지도록 지금 유용한 코드를 작성한다.

#### 성급

- 컴퓨터가 놀고 있는 것에 분노를 느끼는 기질이다.
- 컴퓨터가 충분히 효율적으로 동작하고 있지 않거나 의도대로 동작하지 않는다면 즉시 코드를 다시 작성한다.
- 당면한 문제에 머무르지 않고 향후 일어날 수 있는 문제를 상정해서 코드를 작성해 둔다.

#### 오만

- 천벌을 받을 정도로 넘치는 자존심을 지닌 기질이다.
- 자존심을 갖고 남에게 내놓아도 부끄럽지 않은 코드를 작성한다.

### 태만, 성급, 오만으로 작업을 시스템화

#### 태만

- 일상에서 귀찮은 업무, 몇 번이나 되풀이하는 업무가 많다.
  - 직접하지 않고 태만해질 수 있도록 소프트웨어를 자동화한다.

#### 성급

- 컴퓨터는 본인이 원하는 동작을 해주지 않을 때가 있다.
  - 성급해져서 본인 생각대로 동작할 수 있도록 코드를 바꿔 작성한다.

#### 오만

- 자신의 코드를 누군가가 보더라도 부끄럽지 않게끔 작성하고, 작성한 코드에 대해 책임을 진다.
  - 작업의 성과에 관해서는 오만하게 전문가라는 의식을 갖고 작업에 착수한다.

### 자동화, 서식화, 모듈화

#### 태만

- 반복 업무를 시스템화한다.
- 수작업에 관해서는 코드를 작성하고 툴을 만들어서 자동화한다.
- 수작업의 순서를 명확히하고 나서 자동화할 수 있을 만한 곳을 찾아 자동화하는 방식이 효율적이다.

#### 성급

- 일어날 수 있는 문제를 상정해서 업무를 한다.
- 앞질러 가서 요구사항이 나올 만한 부분을 생각하고 불만이 나오기 전에 대응할 수 있도록 한다.
- 변하지 않는 부분을 기반으로 서식을 만들고 변경될 부분을 변수화해서 자유롭게 변경할 수 있도록 만들어 둔다.

#### 오만

- 남에게 부끄럽지 않게끔 작업하고 보수한다.
- 자기가 만든 소프트웨어는 프로 의식을 갖고 보수하기 쉽게 만들어 둔다.
- 기능으로 정리된 모듈은 다른 소프트웨어를 만들 때 재사용할 수 있다.

### 중노동은 보상받지 못한다

- 자기가 일하는 시간이나 노력을 줄이면 줄일수록 프로젝트에 대한 기여는 커진다.
- 프로그래밍은 몰두하면서 끊임없이 배울 수 있는 업무다.
  - 업무를 하면 할수록 문제 영역에 관한 이해가 깊어지고 같은 목적을 달성하는 데 필요한 노력과 시간은 점차 줄어든다.

## 5.2 보이 스카우트 규칙

### 코드를 청소하고 돌아간다

- 자기가 머물렀던 자리를 떠날 때는 자기가 왔을 때보다 깨끗이 치워야 한다.
- 코드는 자기가 거기 왔을 때보다 깨끗이 하고 나서 자리를 떠나야 한다.

### 코드의 부패를 막는다

- 코드는 항상 깔끔하게 다듬어져 있어야 한다.
- 소프트웨어의 동작을 완전히 정확하게 알기 위해서는 결국 소스 코드를 보는 수밖에 없다.

### 코드는 개선한 다음에 완료

- 코드를 저장소에서 내려받았을 때보다 깨끗이 만들고 나서 완료(commit)한다.
- 완료하기 전에 모든 코드를 완벽하게 만드는 것이 아니라, 내려받은 직후보다 조금이라도 좋은 코드로 만드는 것을 지향한다.

### 프로그래밍은 급할수록 돌아가라

- 코드에 따라서는 지름길을 선택하면 나중에 유지보수할 때 불필요한 비용이 추가될 수 있기 때문이다.

1. 직접적인 가치를 얻을 수 없다는 이유로 단위 테스트 작성을 생략한다.
  - 이렇게 만들어진 소프트웨어는 나중에 변경하기가 매우 어려워진다.
2. 비용 경감을 위해 목적에 적합하지 않은데도 기존 시스템을 억지로 사용한다.
  - 무리를 하는 이상 힘들어지고 언젠가는 파탄이 난다.
3. 부적절한 라이브러리가 선택되어 있다는 사실을 알고도 방치한다.
  - 요구사항의 변화와 함께 해당 라이브러리의 좋지 않은 부분을 감추기 위해 나중에 여분의 계층을 추가해야 한다.

## 5.3 성능 튜닝에 관한 금언

### 빠른 코드보다 좋은 코드

- 성능 튜닝이란 빠른 코드를 작성하는 것으로, 코드의 최적화라고도 불린다.
- 너무 이른 시점의 최적화는 모든 악의 근원이다.
- 성능 튜닝은 프로그래밍의 초기에 고려해야 할 작업이 아니다.
- 프로그래밍에서는 빠른 코드보다 우선 바르고 읽기 쉬운 것에 주안점을 둔 좋은 코드를 작성하는 데 노력해야 한다.

### 빠른 코드는 수지가 맞지 않는다

#### 가독성의 저하

- 최적화라는 처리의 성질상 원래 코드만큼 직접적인 로직은 아니기 때문이다.
- 단순 명쾌하게 갈 수 없으며 의도를 전하기 어려워진다.

#### 품질의 저하

- 코드가 복잡해져 읽기 어려워지면 품질도 저하된다.
- 알고리즘의 흐름이 명로하게 기술되어 있지 않은 코드에서는 오류가 숨어 있는 상태를 놓칠 수 있기 때문이다.

#### 복잡성의 증가

- 최적화에서는 전문적인 백도어를 이용해서 모듈 간의 종속성을 강화하고, 결합도를 높이는 코드나 플랫폼의 고유의 기능을 이용한 코드를 작성한다.
  - 이렇게 교묘한 방법으로 코드를 작성하면 복잡성이 증가하며 이식성도 잃어 버린다.

#### 보수의 저해

- 코드가 복잡해져 읽기 어려워지면 해당 코드의 보수가 난해해진다.
- 코드를 최적화하면 부자연스러운 기술이 늘어나고 처리의 흐름을 따라가기 어려워진다.
- 최적화는 코드의 확장성도 저해한다.

#### 환경 간의 경합

- 최적화는 대부분 환경 특유의 것이다.
- 한 환경에 특화되게끔 최적화되면 다른 환경에서는 성능이 저하될 수 있다.

#### 작업량의 증대

- 최적화를 하면 업무가 또 하나 늘어나는 셈이 된다.
- 최적화는 오랜 시간을 필요로 하는 작업이다.

### 우선 좋은 코드를 작성한다

- 좋은 코드는 정보 은닉의 원칙에 따라 작성되어 있다.
- 좋은 코드를 만들고 나서 튜닝을 하는 쪽이 효율적이다.

### 소프트웨어의 성능

- 소프트웨어의 성능은 코드 이외에도 다양한 요인에 의해 좌우된다.
  - 실행 환경
  - 배치 또는 설치 설정
  - 사용하고 있는 미들웨어
  - 사용하고 있는 라이브러리
  - 상호 운용하고 있는 구 시스템
  - 아키텍처

### 아키텍처의 성능

- 아키텍처를 설계할 때는 성능을 고려하는 쪽이 좋은 경우도 있다.
- 아키텍처의 영향은 광범위하게 걸쳐 있기 때문에 나중에 문제를 발견했을 때 변경이 난해하다.

### 성능 튜닝의 순서

1. 최적화의 필요성을 증명한다.
2. 성능을 계측하고 병목을 특정한다.
3. 병목 코드를 최적화한다.
4. 성능을 계측하고 최적화 효과를 확인한다.
5. 최적화한 코드의 동작에 문제가 없음을 검증한다.

## 5.4 비자아적 프로그래밍

### 자아를 버려라

- 자만과 자존심을 버리고 동료에게 협력을 구하도록 한다.
- 코드를 보는 사람이든 코드를 보여주는 사람이든 자기가 뛰어나다는 식의 자존심은 버리고 순수하게 더 좋은 코드를 만든다는 것에 가치를 두어야 한다.

### 비자아로 품질 향상

- 동료에게 코드를 보여주면서 조언을 겸허하게 수용하는 개발 스타일이 소프트웨어의 품질을 향상시킨다는 사실이 잘 알려져 있다.
- 이런 습관은 팀 환경을 더욱 좋게 만들고 각 구성원의 프로그래밍 실력 향상으로 이어진다.

### 비자아적 프로그래밍의 십계를 지킨다

- 자기 자신도 실수를 저지른다는 점을 이해하고 받아들인다.
- 작성한 코드는 자기 자신이 아니다.
- 아무리 끝까지 간 것 같아도 위에는 그 이상이 있다.
- 상담 없이 코드를 재작성하지 않는다.
- 자기보다 기술이 떨어지는 사람에게도 존경과 경의, 인내를 갖고 대한다.
- 세상에서 유일하게 변하지 않는 것은 변한다는 사실뿐이다.
- 진정한 권위는 지위가 아니라 지식에서 생겨난다.
- 신념을 위해 싸운다. 다만 패배는 깨끗이 수용한다.
- 방에 틀어박혀 있어서는 안 된다.
- 사람에게는 관대하고 코드에는 엄격하게, 사람이 아닌 코드를 비평한다.

### 비자아의 균형

- 일방적으로 자기를 죽이고 자신을 희생하며 남과 팀을 위해 모든 것을 바쳐야 한다는 생각은 한쪽이 지는 건전하지 않은 사고방식이다.
- 자기 멋대로도 좋지 않지만, 자신을 죽이고 개성까지 죽여서는 오히려 팀에 기여할 수 없다.

## 5.5 한 걸음씩 조금씩

### 스텝 바이 스텝

- 프로그래밍은 한 번에 작은 하나만을 수행한다.
- 하나씩 조금씩 단차가 작은 계단을 올라가듯이 작업한다.

### 견실한 걸음이 효율적

- 작지만 확실한 한 걸음을 반복해서 나아가야 결과적으로 품질도 시간 효율도 높아진다.
- 한 걸음씩 나아가면 마지막 한 걸음을 되돌리기가 편하다.
- 한 걸음씩 나아가면 특히 오래된 것을 새로운 것으로 바꾸는 작업을 안전하게 수행할 수 있다.
- 한 걸음씩 나아가는 것은 코드 상태를 파악하고 제어할 수 있다는 점을 의미한다.

### 한 번에 여러 작업을 하지 않는다

- 한 걸음씩 조금씩 작업한다.
- 테스트 구동 개발 중이라면 코드를 단숨에 작성해서 나중에 한꺼번에 테스트를 실행해서는 안 된다.

### 논리적인 사고 요령

- 순식간에 해답을 구하려는 태도는 잘못이다. 곧바로 모르겠더라도 계속 생각해 본다.
- 생각을 시작하자마자 금방 결론으로 건너뛰는 것은 잘못이다. 조건을 충족하는 답을 하나 발견했다고 해서 사고를 멈추지 말고, 선입견을 배제하고 다른 가능성도 검토한다.
- 이미 생각한 것도 제대로 기억해 둔다. 그렇게 하면 똑같은 것을 몇 번이나 되풀이해서 생각하는 사고의 무한루프에 빠지는 일을 피할 수 있다.
- 전부 기억하기란 쉽지 않으니 메모하면서 생각하도록 한다. 메모하면서 생각하는 데는 부차적인 효과가 있다. 적어서 눈에 보이게끔 하면 머릿속에서만 생각했을 때 알지 못했던 것이 왠지 모르게 이해가 갈 수도 있다.
- 논리적으로 생각한다고는 하지만 직감 역시 중요하다. 예를 들어 행렬을 통해 정보가 정리될 것 같다는 생각이 직감적으로 들었다면 일단 그 방법을 시도해본다. 다만 이는 사고 과정에 관한 이야기다. 직감만으로 직접 해답을 구하려는 것은 단순한 때려 맞추기일 뿐, 좋은 습관은 아니다.

## 5.6 TMTOWTDI(There's more than one way to do it)

### 툴의 다양성은 좋은 것

- 다른 사람이 사용할 툴을 설계할 때는 달성하고자 하는 것의 수단을 여러 개 준비한다.
  - 프로그래밍 언어나 DSL, API를 가리킨다.
- 툴 자체는 복잡해지더라도 툴을 사용하는 쪽은 다양한 상황에서도 단순하게 코드를 작성할 수 있다.

### 대상이 다양하면 수단도 다양

- 소프트웨어는 본질적으로 복잡하다.
  - 소프트웨어인 툴 역시 가능한 한 정밀한 방식으로 복잡해지도록 설계한다.
- 갖가지 복잡한 대상을 단순하게 기술하기 위해서는 툴이 어느 정도의 복잡성과 다양성을 갖는 편이 좋다.

### 다양한 선택지를 준비

- 툴을 설계할 때는 방법에 관한 선택지를 다양하게 준비하도록 한다.
- 기본적으로는 간단한 것은 쉽게, 어려운 것은 가능하게를 지향한다.
- 툴을 성질상 만드는 시간보다 사용되는 시간이 압도적으로 많다.
  - 툴을 더 좋은 것으로 만드는 투자에는 레버리지가 필요하다.

### TMTOWTDI와 단순함

- 소프트웨어에서 단순함에 관해서는 상당히 높은 우선도가 주어져야 한다.
- TMTOWTDI에서는 툴인 소프트웨어라면 툴 쪽에서 복잡함을 다루게끔 하고, 클라이언트 쪽에 단순함을 배치한다.
