# Chapter 3 사상-프로그래밍의 이데올로기

## 3.37 UNIX 사상

### UNIX의 근간이 되는 암묵적인 지식

- UNIX 사상은 공식적인 방법론은 아니지만 반쯤은 암묵적인 지식으로 UNIX 문화에서 성장하고 전승됐다.

### UNIX 설계에 대한 판단의 정확성

- UNIX는 대부분의 하드웨어에서 사용되고 있으며 사용법도 다양하다.
- UNIX가 성공한 이유는 초기의 UNIX 프로그래머들이 첫 단계에서 내린 설계에 대한 판단이 정확했다는 데 있다.

### UNIX 사상을 따른다

- UNIX 사상의 내용에는 고난의 프로그래밍 역사를 견뎌온 성취가 있다.

## 3.38 모듈화의 원칙

### 정제된 모듈을 만든다

- 소프트웨어는 복잡하지만, 전체적으로 복잡함의 정도를 낮출 수는 있다.
  - 명료한 인터페이스로 결합한 단순한 모듈들로 소프트웨어를 조립해야 한다.
  - 코드 중에 관계성이 높은 요소를 모아 모듈을 작성한다.

### 모듈 관계가 간결해진다

- 명료한 인터페이스를 지닌 단순한 모듈은 여타 모듈과 그다지 관계를 갖지 않는다.
  - 문제는 국소화되면서 전체를 망가뜨리지 않고 대상 모듈만을 개선하는 것이 가능해진다.

### 모듈의 입구를 좁게 만든다

- 모듈이 제공하는 인터페이스는 불필요한 것은 제외하고 가장 적게 만든다.
- 모듈의 구성요소는 관계성이 높은 것만 모아 놓도록 한다.

## 3.39 명확성의 원칙

### 코드를 명확히 한다

- 복잡한 코드는 읽기 어려우며 그 부분에서 오류가 발생한다.
- 명확한 코드는 쉽게 이해할 수 있으면서 좀처럼 망가지지 않는다.

### 코드를 읽는 것은 기계가 아닌 사람이다

- 유지보수는 반드시 거쳐야 하는 중요한 단계로 비용이 많이 드는 업무다.
  - 대체로 신규 개발보다 비용이 많이 들어간다.

### 명확하지 않으면 개선한다

- 코드를 읽을 때 이해하기 어려운 코드에 대해 해독을 3회 이상 반복해서는 안 된다.
- 코드에 주석을 달거나 코드를 읽기 쉽게 수정한다.

## 3.40 구성의 원칙

### 필터로 조립한다

- 소프트웨어를 다른 소프트웨어와 조합할 수 있도록 만든다.
  - 이는 소프트웨어를 가능한 한 단순하게 필터로 만든다는 뜻이다.
- 필터란 입력으로 데이터 스트림을 받아들여 가공한 다음 다른 데이터 스트림으로 출력하는 소프트웨어를 말한다.

### 상호 연결로 상승 효과

- 소프트웨어를 사용할 수 있는 부품으로 만들려면 독립성이 필요하다.
- 독립되어 있으면 연계할 소프트웨어는 연계 대상에 관해 별로 고민하지 않아도 된다.

### 텍스트를 입출력하는 명령을 만든다

- 텍스 스트림을 읽고 쓰는, 명령행에서 사용할 수 있는 소프트웨어를 설계한다.
- 직렬화된 프로토콜 같은 인터페이스보다는 텍스트 스트림과 같은 단순한 인터페이스를 선택해야 여러 소프트웨어를 조합해 다른 작업에 이용할 수 있다.
- 데이터 변환에 다소 오버헤드가 있더라도 범용적인 텍스트 형식의 데이터 스트림을 자유롭게 읽고 쓸 수 있는 편리함을 누려야 한다.

## 3.41 분리의 원칙

### 메커니즘에서 정책을 분리한다

- 정책
  - 해당 소프트웨어의 전제에 종속되는 부분이다.
  - 코드 중에서 비교적 불안정하다.
  - 비즈니스 로직이나 사용자 인터페이스가 정책에 해당한다.
- 메커니즘
  - 해당 소프트웨어의 전제에 종속되지 않는 부분이다.
  - 코드 중에서는 비교적 안정적이다.
  - 그래픽 처리의 래스터 변환 등 엔진 역할을 수행하는 부분이 메커니즘에 해당한다.
  
### 메커니즘은 안정, 정책은 불안정

- 정책이 경직되면서 사용자의 요구에 맞춰 정책을 변경하기 어려워진다.
- 정책을 변경하려고 하면 모처럼 안정된 메커니즘까지 변경해야 한다.
- 정책과 메커니즘을 분리하면 이런 결점이 해소되며 다음과 같은 장점을 얻을 수 있다.
  - 메커니즘을 망가뜨리지 않고 새로운 정책을 시도할 수 있다.
  - 메커니즘이 독립되어 있으므로 효과적인 메커니즘 테스트를 작성하기가 쉽다. 메커니즘은 수명이 긴 편이므로 투자 대비 효과가 높은 테스트다.
  - 메커니즘이 독립되어 있으면 다른 소프트웨어에서 재사용하는 것도 가능하다.
- 정책은 메커니즘보다 훨씬 빠른 속도로 변화한다.
  - 사용자 인터페이스의 스타일에 관한 유행은 금세 변하지만, 래스터 변환이나 도형 합성 로직은 자주 바뀌지 않는다.

### 분리된 정책을 개선

- 소프트웨어 중에서 안정적인 부분과 불안정한 부분을 명확하게 나눠 관리한다.
- 서비스계 애플리케이션
  - 프론트엔드와 백엔드로 모듈을 분할한다.
  - 통신 프로토콜을 이해하고 클라이언트의 요구사항을 받아들이는 프론트엔드가 정책, 실제 서비스를 수행하는 백엔드가 메커니즘이다.
    - 2개의 모듈은 같은 기능을 구현한 단일 모듈보다 복잡함이 줄어들고, 오류가 줄어들며 소프트웨어 전체의 비용은 내려간다.
- 편집 애플리케이션
  - 편집 기능을 확장하는 모듈을 설정 파일로 구동할 수 있도록 한다.
  - 확장 가능한 사용자 인터페이스가 정책, 편집 엔진이 메커니즘이다.
    - 내부 모듈 분할이 명확해질 뿐만 아니라 사용자가 자유롭게 확장할 수 있는 기능을 제공할 수 있다.

## 3.42 단순성의 원칙

### 코드는 단순하게 한다

- 코드가 단순해지도록 설계한다.
- 프로그래밍에는 코드가 복잡해지는 압력이 존재한다.
  - 이를 극복하려면 단순하다는 것의 가치를 서로 인정하는 문화가 필요하다.

### 코드는 그냥 두면 복잡해진다

- 기술을 과시하고자 하는 프로그래머의 심리
  - 결과적으로 설계의 복잡함이 팀의 프로그래밍 능력이나 디버깅 능력 수준을 뛰어 넘고 말아 많은 비용이 드는 실패를 초래한다.
- 기능에 대한 외부로부터의 요구
  - 기능은 끊임없이 변하는 시장의 트렌드에 의해서 지배받는다.
  - 결과적으로 코드는 팽창하여 거대해지고 복잡해지며 오류를 일으키기 쉬운 코드가 된다.

### 단순함을 아릅답게 여기는 문화 구축

- 코드가 팽창하여 복잡해지는 상태를 단호히 거부한다. 반대로 단순한 해결 방법을 서로 높게 평가한다.
- 다수의 기능으로 소프트웨어를 화려하게 꾸미려는 압력에는 반사적으로 저항한다. 반대로 서로 연동하는 작은 부품으로 분할하는 방법을 찾는다.

## 3.43 절약의 원칙

### 큰 코드는 작성하지 않는다

- 큰 코드는 작성하지 않도록 한다.
- 별다른 수가 없다는 것이 명확하게 증명되지 않는 이상 큰 코드는 작성해서는 안 된다.

### 큰 코드는 제어 불능

- 코드가 커지는 것을 허용하면 코드가 복잡해져 유지복수에 지장이 생긴다.

### 코드를 계속 덧붙이지 않는다

- 일단은 작은 코드를 작성하도록 한다.
- 코드를 덧붙여서 코드가 커졌다면 코드를 분할한다.
- 분할에 실패했을 때에 한해서만 큰 코드를 남겨 놓도록 한다.

## 3.44 투명성의 원칙

### 소프트웨어 동작의 시각화

- 소프트웨어의 동작을 바깥에서 이해하기 쉽게 보이도록 설계한다.
- 투명성
  - 소프트웨어의 동작에 관해 한눈에 봐도 곧바로 무엇을 어떻게 하고 있는지를 이해할 수 있을 것
- 개시성
  - 소프트웨어 내부 상태에 관해 감시할 수 있거나 보여줄 수 있을 것

### 디버깅에 기여

- 투명성과 개시성을 지니게끔 하는 설계가 직접적으로 사용자에게 기여하는 것은 아니지만, 프로젝트 전체에는 암묵적으로 좋은 영향을 미친다.
- 소프트웨어의 동작을 시각화하면 디버깅이나 오류 확인이 간단해진다.
- 투명성과 개시성을 목표로 하면 다른 개발 도구에서 간단히 조작할 수 있는 연계를 위한 단순한 인터페이스를 쉽게 얻을 수 있다.

### 동작의 시각화를 기능화한다

- 디버깅을 위한 기능을 설계 초기 단계에 넣어 둔다.
- 동작의 시각화 기능을 프로그래밍할 때 함께 코드에 넣어 둔다.

## 3.45 안정성의 원칙

### 소프트웨어를 안정시킨다

- 소프트웨어가 안정되어 있다는 말은 일반적인 조건뿐만 아니라 예상외의 조건에서도 적절하게 동작하는 것을 뜻한다.
- 예상외의 조건까지 고려하다 보면 코드가 복잡해지는 경향이 있다.
- 안정적인 소프트웨어로 만들려면 내부 구조를 쉽게 설명할 수 있어야 한다.
- 투명성
  - 코드를 예측할 수 있어서 무엇이 일어나고 있는지를 금방 이해할 수 있다면 해당 코드는 투명하다.
- 단순성
  - 코드로 이루어지는 동작이 복잡하지 않아서 모든 분기 조건을 어려움 없이 설명할 수 있다면 해당 코드는 단순하다.

### 소프트웨어는 견고해야 한다

- 불안정한 소프트웨어는 사용자에게 제공하는 가치가 현저하게 낮아진다.
- 안정을 위해 내부 구조는 쉽게 설명할 수 있어야 하는 상태여야 한다.

### 코드를 투명화하고 단순화한다

- 코드 리뷰
  - 코드를 작성한 프로그래머가 코드의 내부 구조에 관해 올바르게 설명할 수 없다면 이는 위험 신호다.
- 특이한 입력이나 극단적으로 큰 입력에 견딜 수 있음을 검증
  - 다른 소프트웨어를 사용해서 입력을 하면 효과적으로 테스트할 수 있다.
