# Chapter 3 사상-프로그래밍의 이데올로기

## 3.37 UNIX 사상

### UNIX의 근간이 되는 암묵적인 지식

- UNIX 사상은 공식적인 방법론은 아니지만 반쯤은 암묵적인 지식으로 UNIX 문화에서 성장하고 전승됐다.

### UNIX 설계에 대한 판단의 정확성

- UNIX는 대부분의 하드웨어에서 사용되고 있으며 사용법도 다양하다.
- UNIX가 성공한 이유는 초기의 UNIX 프로그래머들이 첫 단계에서 내린 설계에 대한 판단이 정확했다는 데 있다.

### UNIX 사상을 따른다

- UNIX 사상의 내용에는 고난의 프로그래밍 역사를 견뎌온 성취가 있다.

## 3.38 모듈화의 원칙

### 정제된 모듈을 만든다

- 소프트웨어는 복잡하지만, 전체적으로 복잡함의 정도를 낮출 수는 있다.
  - 명료한 인터페이스로 결합한 단순한 모듈들로 소프트웨어를 조립해야 한다.
  - 코드 중에 관계성이 높은 요소를 모아 모듈을 작성한다.

### 모듈 관계가 간결해진다

- 명료한 인터페이스를 지닌 단순한 모듈은 여타 모듈과 그다지 관계를 갖지 않는다.
  - 문제는 국소화되면서 전체를 망가뜨리지 않고 대상 모듈만을 개선하는 것이 가능해진다.

### 모듈의 입구를 좁게 만든다

- 모듈이 제공하는 인터페이스는 불필요한 것은 제외하고 가장 적게 만든다.
- 모듈의 구성요소는 관계성이 높은 것만 모아 놓도록 한다.

## 3.39 명확성의 원칙

### 코드를 명확히 한다

- 복잡한 코드는 읽기 어려우며 그 부분에서 오류가 발생한다.
- 명확한 코드는 쉽게 이해할 수 있으면서 좀처럼 망가지지 않는다.

### 코드를 읽는 것은 기계가 아닌 사람이다

- 유지보수는 반드시 거쳐야 하는 중요한 단계로 비용이 많이 드는 업무다.
  - 대체로 신규 개발보다 비용이 많이 들어간다.

### 명확하지 않으면 개선한다

- 코드를 읽을 때 이해하기 어려운 코드에 대해 해독을 3회 이상 반복해서는 안 된다.
- 코드에 주석을 달거나 코드를 읽기 쉽게 수정한다.

## 3.40 구성의 원칙

### 필터로 조립한다

- 소프트웨어를 다른 소프트웨어와 조합할 수 있도록 만든다.
  - 이는 소프트웨어를 가능한 한 단순하게 필터로 만든다는 뜻이다.
- 필터란 입력으로 데이터 스트림을 받아들여 가공한 다음 다른 데이터 스트림으로 출력하는 소프트웨어를 말한다.

### 상호 연결로 상승 효과

- 소프트웨어를 사용할 수 있는 부품으로 만들려면 독립성이 필요하다.
- 독립되어 있으면 연계할 소프트웨어는 연계 대상에 관해 별로 고민하지 않아도 된다.

### 텍스트를 입출력하는 명령을 만든다

- 텍스 스트림을 읽고 쓰는, 명령행에서 사용할 수 있는 소프트웨어를 설계한다.
- 직렬화된 프로토콜 같은 인터페이스보다는 텍스트 스트림과 같은 단순한 인터페이스를 선택해야 여러 소프트웨어를 조합해 다른 작업에 이용할 수 있다.
- 데이터 변환에 다소 오버헤드가 있더라도 범용적인 텍스트 형식의 데이터 스트림을 자유롭게 읽고 쓸 수 있는 편리함을 누려야 한다.

## 3.41 분리의 원칙

### 메커니즘에서 정책을 분리한다

- 정책
  - 해당 소프트웨어의 전제에 종속되는 부분이다.
  - 코드 중에서 비교적 불안정하다.
  - 비즈니스 로직이나 사용자 인터페이스가 정책에 해당한다.
- 메커니즘
  - 해당 소프트웨어의 전제에 종속되지 않는 부분이다.
  - 코드 중에서는 비교적 안정적이다.
  - 그래픽 처리의 래스터 변환 등 엔진 역할을 수행하는 부분이 메커니즘에 해당한다.
  
### 메커니즘은 안정, 정책은 불안정

- 정책이 경직되면서 사용자의 요구에 맞춰 정책을 변경하기 어려워진다.
- 정책을 변경하려고 하면 모처럼 안정된 메커니즘까지 변경해야 한다.
- 정책과 메커니즘을 분리하면 이런 결점이 해소되며 다음과 같은 장점을 얻을 수 있다.
  - 메커니즘을 망가뜨리지 않고 새로운 정책을 시도할 수 있다.
  - 메커니즘이 독립되어 있으므로 효과적인 메커니즘 테스트를 작성하기가 쉽다. 메커니즘은 수명이 긴 편이므로 투자 대비 효과가 높은 테스트다.
  - 메커니즘이 독립되어 있으면 다른 소프트웨어에서 재사용하는 것도 가능하다.
- 정책은 메커니즘보다 훨씬 빠른 속도로 변화한다.
  - 사용자 인터페이스의 스타일에 관한 유행은 금세 변하지만, 래스터 변환이나 도형 합성 로직은 자주 바뀌지 않는다.

### 분리된 정책을 개선

- 소프트웨어 중에서 안정적인 부분과 불안정한 부분을 명확하게 나눠 관리한다.
- 서비스계 애플리케이션
  - 프론트엔드와 백엔드로 모듈을 분할한다.
  - 통신 프로토콜을 이해하고 클라이언트의 요구사항을 받아들이는 프론트엔드가 정책, 실제 서비스를 수행하는 백엔드가 메커니즘이다.
    - 2개의 모듈은 같은 기능을 구현한 단일 모듈보다 복잡함이 줄어들고, 오류가 줄어들며 소프트웨어 전체의 비용은 내려간다.
- 편집 애플리케이션
  - 편집 기능을 확장하는 모듈을 설정 파일로 구동할 수 있도록 한다.
  - 확장 가능한 사용자 인터페이스가 정책, 편집 엔진이 메커니즘이다.
    - 내부 모듈 분할이 명확해질 뿐만 아니라 사용자가 자유롭게 확장할 수 있는 기능을 제공할 수 있다.

## 3.42 단순성의 원칙

### 코드는 단순하게 한다

- 코드가 단순해지도록 설계한다.
- 프로그래밍에는 코드가 복잡해지는 압력이 존재한다.
  - 이를 극복하려면 단순하다는 것의 가치를 서로 인정하는 문화가 필요하다.

### 코드는 그냥 두면 복잡해진다

- 기술을 과시하고자 하는 프로그래머의 심리
  - 결과적으로 설계의 복잡함이 팀의 프로그래밍 능력이나 디버깅 능력 수준을 뛰어 넘고 말아 많은 비용이 드는 실패를 초래한다.
- 기능에 대한 외부로부터의 요구
  - 기능은 끊임없이 변하는 시장의 트렌드에 의해서 지배받는다.
  - 결과적으로 코드는 팽창하여 거대해지고 복잡해지며 오류를 일으키기 쉬운 코드가 된다.

### 단순함을 아릅답게 여기는 문화 구축

- 코드가 팽창하여 복잡해지는 상태를 단호히 거부한다. 반대로 단순한 해결 방법을 서로 높게 평가한다.
- 다수의 기능으로 소프트웨어를 화려하게 꾸미려는 압력에는 반사적으로 저항한다. 반대로 서로 연동하는 작은 부품으로 분할하는 방법을 찾는다.

## 3.43 절약의 원칙

### 큰 코드는 작성하지 않는다

- 큰 코드는 작성하지 않도록 한다.
- 별다른 수가 없다는 것이 명확하게 증명되지 않는 이상 큰 코드는 작성해서는 안 된다.

### 큰 코드는 제어 불능

- 코드가 커지는 것을 허용하면 코드가 복잡해져 유지복수에 지장이 생긴다.

### 코드를 계속 덧붙이지 않는다

- 일단은 작은 코드를 작성하도록 한다.
- 코드를 덧붙여서 코드가 커졌다면 코드를 분할한다.
- 분할에 실패했을 때에 한해서만 큰 코드를 남겨 놓도록 한다.

## 3.44 투명성의 원칙

### 소프트웨어 동작의 시각화

- 소프트웨어의 동작을 바깥에서 이해하기 쉽게 보이도록 설계한다.
- 투명성
  - 소프트웨어의 동작에 관해 한눈에 봐도 곧바로 무엇을 어떻게 하고 있는지를 이해할 수 있을 것
- 개시성
  - 소프트웨어 내부 상태에 관해 감시할 수 있거나 보여줄 수 있을 것

### 디버깅에 기여

- 투명성과 개시성을 지니게끔 하는 설계가 직접적으로 사용자에게 기여하는 것은 아니지만, 프로젝트 전체에는 암묵적으로 좋은 영향을 미친다.
- 소프트웨어의 동작을 시각화하면 디버깅이나 오류 확인이 간단해진다.
- 투명성과 개시성을 목표로 하면 다른 개발 도구에서 간단히 조작할 수 있는 연계를 위한 단순한 인터페이스를 쉽게 얻을 수 있다.

### 동작의 시각화를 기능화한다

- 디버깅을 위한 기능을 설계 초기 단계에 넣어 둔다.
- 동작의 시각화 기능을 프로그래밍할 때 함께 코드에 넣어 둔다.

## 3.45 안정성의 원칙

### 소프트웨어를 안정시킨다

- 소프트웨어가 안정되어 있다는 말은 일반적인 조건뿐만 아니라 예상외의 조건에서도 적절하게 동작하는 것을 뜻한다.
- 예상외의 조건까지 고려하다 보면 코드가 복잡해지는 경향이 있다.
- 안정적인 소프트웨어로 만들려면 내부 구조를 쉽게 설명할 수 있어야 한다.
- 투명성
  - 코드를 예측할 수 있어서 무엇이 일어나고 있는지를 금방 이해할 수 있다면 해당 코드는 투명하다.
- 단순성
  - 코드로 이루어지는 동작이 복잡하지 않아서 모든 분기 조건을 어려움 없이 설명할 수 있다면 해당 코드는 단순하다.

### 소프트웨어는 견고해야 한다

- 불안정한 소프트웨어는 사용자에게 제공하는 가치가 현저하게 낮아진다.
- 안정을 위해 내부 구조는 쉽게 설명할 수 있어야 하는 상태여야 한다.

### 코드를 투명화하고 단순화한다

- 코드 리뷰
  - 코드를 작성한 프로그래머가 코드의 내부 구조에 관해 올바르게 설명할 수 없다면 이는 위험 신호다.
- 특이한 입력이나 극단적으로 큰 입력에 견딜 수 있음을 검증
  - 다른 소프트웨어를 사용해서 입력을 하면 효과적으로 테스트할 수 있다.

## 3.46 표현성의 원칙

### 정보는 데이터에 모아 표현

- 코드에서 정보를 표현할 때는 로직이 아닌 데이터에 모아 작성하는 방식으로 한다.
- 정보를 데이터에 고정시킴으로써 로직은 읽기 쉬워지고 안정된다.
- 자료구조를 활용하면 매우 복잡한 것이라도 간단히 모델링할 수 있고 더욱 간단히 표현을 할수도 있다.

### 데이터는 로직보다 다루기 쉽다

- 사람 입장에서 절차적인 로직은 쉽게 이해하기 힘들다.
- 자료구조는 복잡한 것이라도 비교적 쉽게 이해할 수 있다.
  - 데이터는 로직보다 다루기 쉽다.

### 복잡함을 데이터에 모은다

- 코드상에서 피할 수 없는 복잡한 부분이 있다면 데이터에 모으도록 한다.
- 로직과 자료구조 중에 선택해야 한다면 자료구조가 복잡해지는 쪽으로 한다.

## 3.47 충격 최소의 원칙

### 예상대로 동작하는 인터페이스

- 인터페이스는 사용하는 사람이 상상하는 형태대로 동작하도록 설계한다.
- 사용하는 사람의 충격이 최소가 되게끔 설계해야 한다.

### 학습 비용이 낮아진다

- 가장 쉽게 사용할 수 있는 소프트웨어란 사용자가 새롭게 배워야 하는 것이 가장 적은 소프트웨어다.
- 사용자가 애초에 가진 지식에 가장 효과적으로 연계될 수 있는 소프트웨어를 뜻한다.

### 사용자의 기존 지식을 활용한다

- 유사한 점이 많은 소프트웨어의 인터페이스를 모델로 삼는다.
- 예상 사용자의 특징을 고려한다.
- 전통에 주의를 기울인다.
- 언뜻 보면 비슷하지만 미묘하게 다른 상황을 피한다.

## 3.48 침묵의 원칙

### 소프트웨어는 과묵해야

- 소프트웨어는 표시를 최소한으로 줄이고 과묵하게 작업을 수행해야 한다.
- 반드시 알려야 하는 예상외의 상황이 아니라면 소프트웨어는 아무것도 말하지 않도록 한다.

### 중요한 정보를 전하기 쉽다

- 메시지 출력이 많으면 사용자는 자기 관점에서 중요한 정보가 무엇인지를 알 수 없다.
- 표시를 엄선하는 과정을 거쳐 모두 중요한 정보만 표시된다면 사용자는 정보를 구분 지을 필요가 없다.
- 꼭 필요할 때 이외에는 사용되어서는 안된다.

### 중요한 정보만을 표시하여 출력

- 실제로 발생한 오류만을 표준 오류 출력으로 표시하고 그 밖에 요구되지 않은 데이터는 일체 출력하지 않도록 한다.
- 디버깅 목적으로 진행 상황에 관해 메시지를 표시하고 싶다면 장황하게 switch 문을 만들고, 일반적인 상황에서는 사용되지 않게 비활성화 한다.

## 3.49 복구의 원칙

### 복구 실패시는 처리 정지

- 소프트웨어 동작 중 오류 복구에 실패했다면 처리를 계속해서는 안 된다.
- 소프트웨어의 동작은 평상시뿐만 아니라 실패시에도 투명해야 한다.

### 오류시 계속되는 실행은 피해 확대

- 복구에 성공하지 못했는데도 처리를 계속하면 오류 발생 시의 시나리오로서는 최악의 상황에 빠진다.

### 오류 통지는 요란하게

- 오류가 발생했을 때는 가능하면 조기에 요란하게 통지하도록 한다.
- 소프트웨어가 스스로 회복할 수 없을 때는 무리해서 계속 처리하지 말고 사용자가 빨리 알아차리게끔 만들어서 사용자의 판단을 받는 것이 중요하다.

### 소프트웨어 입출력에 관한 금언

- 입력에 관해서는 잘못된 형식이라도 가능한 적절한 의미를 끄집어내서 관용적으로 받아들여야 하고, 출력에 관해서는 엄밀히 따져 명료하고도 정확한 데이터를 송출해야 한다.

## 3.50 경제성의 원칙

### 프로그래머의 시간을 소중히

- 다음과 같은 문제가 프로그래머의 시간을 낭비하게 만든다.
  - 빈약한 하드웨어
  - 사용 소프트웨어에 대한 제한
  - 환경에 관한 규제와 제한

### 프로그래머의 시간은 귀중

- 설비에 투자해서 프로그래머가 효율적이면서도 기분 좋게 업무를 할 수 있다면 투자는 쉽게 회수할 수 있다.

### 프로그래머에게 투자한다

- 설비에 투자하는 형태로 간접적으로 프로그래머에게 투자한다면 수지는 분명 플러스가 된다.
- 개발 효과가 높아지고 스트레스는 내려가므로 생산성과 품질이 매우 향상될 것이다.

## 3.51 생성의 원칙

### 코드를 작성하는 코드를 작성한다

- 코드를 생성하는 코드를 작성한다.
- 수작업을 피하고 코드를 작성하기 위한 코드를 작성하도록 한다.

### 생성된 코드는 값싸고 고품질

- 코드에 대한 수동적인 단순 작업은 인간의 감각을 마비시켜 지연이나 실수의 원인이 된다.
- 생성된 코드는 프로그래머가 손으로 작성한 코드보다 항상 싸게 먹히면서도 고품질이다.

### 코드 생성기를 만든다

- 코드 생성기를 적재적소에 작성한다.
- 반복이 많고 정형적인 코드는 코드 생성기의 대상으로 한다.

## 3.52 최적화의 원칙

### 빠른 코드보다 바른 코드

- 프로그래밍에서 최적화란 성능 튜닝을 뜻한다.
  - 동작 속도를 높이고 메모리나 디스크 공간 등 머신 자원의 사용을 효율화하는 작업이다.
- 프로그래밍에서는 코드를 최적화하기 전에 바르게 동작하는 코드를 작성하도록 한다.

### 조기의 빠른 코드는 설계를 파탄 나게 만든다

- 최적화에 집착하면 다음과 같은 문제가 발생한다.
  - 투명성이나 단순성이 희생된다.
  - 부분적인 어중간한 최적화가 전체의 최적화를 방해한다.

### 바르게 만든 다음에 빠르게 만든다

- 먼저 바른 코드를 만든 다음에 빠르게 만든다.
- 코드의 단순한 상태를 유지하고, 다음에 체계적으로 찾아 최적화를 수행한다.

### 프로토타입으로 최적화

- 프로토타입을 사용하면 코드를 작성하지 않아도 되는 기능이 파악된다.
- 코드를 작성하지 않는 것은 성능을 올리는 데 기여한다.

## 3.53 다양성의 원칙

### 선택의 다양성을 수용한다

- 소프트웨어에서는 선택의 다양성을 수용한다.
- 유일하게 바른 방법은 존재하지 않는다.

### 인간의 상상력에는 한계가 있다

- 모든 면에서 최적인 것을 만들 수 있는 사람일지라도 모든 용도까지 예측하기란 불가능하다.

### 더 좋은 방식을 계속 찾는다

- 다양성을 인정해서 사고를 멈추지 말고 더 좋은 방식을 계속 모색한다.
- 단 한 번의 배포로 사용자의 모든 요구에 완벽하게 대응할 수는 없다.

## 3.54 확장성의 원칙

### 확장할 수 있게 설계한다

- 확장성을 고려한 설계를 수행한다.
- 코드에는 성장의 여지를 남겨 둔다.

### 소프트웨어는 성장해야 한다

- 확장성을 미리 고려하지 않으면 호환성을 유지하면서 코드를 바꿔 작성할 수 없다.
- 최초의 설계가 누락 없이 완벽할 수는 없다.

### 연결 가능한 설계

- 소프트웨어가 연결 가능(pluggable)하도록 설계해야 한다.
- 확장을 위한 연결부를 유연하게 만들어 코드 안에 주석을 달아 둔다.

### 자기 설명적인 데이터 형식

- 확장성의 원칙은 데이터 형식(데이터 레이아웃, 데이터 포맷)에도 적용된다.
- 프로토콜이나 파일 형식을 설계할 때는 자기 설명적으로 만들어 확장할 수 있도록 한다.
