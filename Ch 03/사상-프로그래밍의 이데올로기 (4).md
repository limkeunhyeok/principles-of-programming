# Chapter 3 사상-프로그래밍의 이데올로기

## 3.15 패키지화

### 모듈을 그룹핑

- 모듈을 의미 있는 단위로 모은 다음 그룹화하고, 이렇게 분할된 단위를 패키지라고 한다.
- 패키지는 소프트웨어의 논리 구조를 물리 구조에 저장하는 방법을 결정한다.

### 모듈의 복잡도를 낮춘다

- 코드의 관련 요소를 캡슐화하여 모듈을 작성하면 코드가 정리되고 복잡도가 낮아진다.
  - 하지만 대규모 소프트웨어가 되면 대량으로 작성된 모듈이 오히려 복잡성을 낳는 결과를 초래한다.
- 패키지화는 다음과 같은 이점이 있다.
  - 소프트웨어 전체가 패키지라는 작은 단위로 분할되므로 복잡도가 낮아진다.
  - 패키지 안에 관련 없은 모듈이 섞이지 않으므로 모듈을 관리하기 쉬워진다.
  - 수정에 대한 영향도가 패키지 안에 머무를 가능성이 높으므로 코드를 변경하기 쉬워진다.
  - 종속 관계가 정리되어 패키지 단위로 재사용하기 쉬워진다.

### 상향식으로 패키지 설계

- 패키지 설계는 모듈이 어느 정도 만들어진 다음에 상향식으로 설계한다.
- 개발이 진행되다 보면 모듈이 점점 늘어난다.

## 3.16 관심의 분리

### 관심별로 코드를 분리

- 관심이란 소프트웨어의 기능이나 목적을 뜻한다.
- 관심을 분리한다는 것은 각각의 관심에 관련된 코드를 모아 독립된 모듈로 만들어 다른 코드로부터 분리한다는 뜻이다.

### 관심 단위로 변경이 이루어진다

- 관심별 분리의 이점
  - 관심별로 독립해서 수정할 수 있으므로 읽는 범위가 한정되고 변경이 쉬워진다.
  - 영향 범위가 관심 안에 머무르므로 변경 시 품질이 안정된다.
  - 코드를 작성할 때는 관심 단위로 개발하므로 분업, 병행하여 개발을 진행할 수 있다.

### 관심 단위로 모듈화

- 관심별로 모듈을 작성하여 서로 다른 책임이나 관계없는 책임은 분리해 둔다.

### 관점 지향 프로그래밍

- 관점 지향 프로그래밍(AOP: Aspect-Oriented Programming)은 관심 중에서도 횡단적 관심을 분리한 기술이다.
- 횡단적 관심이란 각 관심을 옆쪽에서 꼬챙이로 꿰는 듯한 관심을 뜻한다.
- 일반적으로 횡단적 관심은 분리되지 않은 상태로 각 기능에 산재해 있는데, 이는 코드의 변경을 방해하는 커다란 요인이다.

## 3.17 충족성, 완전성, 프리미티브성

### 표현이 충분하고 완벽하면서 순수함

- 충족성
  - 모듈이 표현하고자 하는 추상이 그것을 전하기에 충분한지를 뜻한다.
- 완전성
  - 모듈이 표현하고자 하는 추상이 모든 특징을 갖추고 있는지를 뜻한다.
- 프리미티브성
  - 모듈이 표현하고 하는 추상이 모두 순수한지 아닌지를 의미한다.

### 표현하고 있는 추상을 정확히 전한다

- 모듈이 표현하고자 하는 추상은 의도가 사용하는 사람에게 전해져야 하고, 유용해야 한다.
- 모듈이 충분하지 않으면 정보가 부족해서 클라이언트는 모듈의 본질을 놓친다.
- 모듈이 완전하지 않으면 클라이언트가 안심하고 사용할 수 없다.
- 모듈이 프리미티브하지 않으면 클라이언트가 모듈을 사용하기 어려워진다.

### 모듈의 추상을 빈틈없이 표현

- 정보는 너무 많아도 너무 적어도 전달되지 않는다.
- 모듈이 제공하는 함수는 충분하고 완전하며 순수한 라인업이어야 한다.

## 3.18 정책과 구현의 분리

### 정책과 구현은 섞지 않는다

- 정책 모듈
  - 해당 소프트웨어의 전체에 종속되는 비즈니스 로직이다.
- 구현 모듈
  - 해당 소프트웨어의 전제에 종속되지 않는 독립된 로직 부분이다.

### 구현은 안정적이지만 정책은 불안정

- 구현 모듈은 특정 소프트웨어에 종속되지 않는 순수한 모듈이므로 다른 소프트웨어에서도 재사용할 수 있다.
- 정책 모듈은 해당 소프트웨어에 특화더이 있어, 해당 소프트웨어가 변경되면 정책 모듈은 변경을 강요당한다.

### 정책과 구현은 별개 모듈로

- 소프트웨어의 전제체 종속되는 부분인 정책과 종속되지 않는 부분인 구현을 의식해서 설계한다.
- 분리할 수 없을 때 적어도 모듈 내에서 정책 부분과 구현 부분을 명확히 알 수 있도록 표현해 두어야 한다.

## 3.19 인터페이스와 구현의 분리

### 구성은 인터페이스와 구현으로

- 인터페이스 파트
  - 모듈이 가진 기능을 정의하고 모듈의 사용방법을 정하는 부분이다.
- 구현 파트
  - 모듈이 가진 기능을 실현하는 코드 부분이다.

### 사용자는 인터페이스만 알면 된다

- 인터페이스와 구현이 분리되면 모듈을 사용하는 클라이언트는 구현에 대한 상세를 알 필요가 없어진다.
- 인터페이스와 구현이 분리되면 클라이언트에서의 사용법(=인터페이스)과 기능의 실현 방법(=구현)이 서로 독립성을 확보할 수 있다.

### 인터페이스를 사용해서 설계한다

- 모듈에 관한 설계 원리로 구현이 아닌 인터페이스에 맞춰 프로그래밍 한다.

## 3.20 참조의 단일성

### 정의는 한 번만

- 모듈의 요소에 관한 선언과 정의는 1회로 제한한다.
- 변숫값의 변화를 추적하지 않아도 되므로 직관적인 코드가 된다.

### 부작용이 없는 프로그래밍

- 프로그래밍에서 부작용이란 어떤 기능이 모듈의 상태를 변화시켜 이후로 얻게 될 결과에 영향을 미친다는 뜻이다.
- 부작용을 갖지 않으면 상태 변화 없이 항상 같은 결과를 얻을 수 있기 때문에 상황 종속에 따른 오류 발생을 줄일 수 있다.

### 단일 대입을 한다

- 단일 대입이란 변수에 값을 재대입하지 않는 것이다.
- 부작용을 피하려면 변수를 변하지 않는 것으로 파악해 처음 한 번 대입한 값은 나중에 변경하지 않도록 한다.
- 최대한 상수를 이용하거나 코드 규약 등의 규칙으로 재대입을 제한하는 등 언어 사양의 제약에 얽매이지 말고 부작용이 없는 코드를 작성하도록 한다.

### 변수 제어의 코드 품질을 올린다

- 오류가 발생하기 쉬운 부분은 필연성이 없는 가변(mutable)의 변수다.
  - 불필요한 가변성을 제거하고 불변(immutable)의 변수를 늘린다면 품질이 향상된다.
- 가변의 변수는 해당 변수에 접근하는 로직이나 스코프를 최대한 줄인다.

### 참조 투과성

- 호출 결과가 파라미터에만 종속된다.
  - 같은 입력에 항상 같은 출력 값을 받는다(이를 순수하다고 표현한다).
- 호출이 다른 기능의 동작에 영향을 주지 않는다.
  - 함수가 부작용을 갖지 않는 특성이다.
- 참조 투과성을 충족하는 함수는 동작이 외부 상태로부터 독립적이고 자기 완결적이다.
  - 테스트가 쉬워지고, 최적화도 수행하기 쉬워진다.

## 3.21 분할 정복

### 커다란 문제를 잘게 나눈다

- 그대로는 해결하기 어려운 커다란 문제는 여러 개의 작은 문제로 분할해서 개별적으로 해결한다.

### 커다란 상태로는 제어 불능

- 커다란 문제를 그 자체로 해결하려면 어려워지고 시간이 많이 걸린다.
- 제어하기 쉬운 규모까지 문제를 분할하고 거기서부터 착수하는 방식이 효율적이다.

### 잘게 쪼개 각개 격파

- 소프트웨어 전체를 설계할 때는 독립해서 설계할 수 있는 부분으로 분할한 다음 착수한다.
- 모듈을 설계할 때는 책임과 책무라는 관점에서 모듈을 분할하도록 한다.
- 알고리즘을 설계할 때는 병합 정렬처럼 상향식으로 분할하고 나서 문제를 해결할 수 없는지를 검토한다.
- 대량의 데이터를 처리하는 설계를 할 때는 MapReduce처럼 계산을 작은 단위로 분할하여 분산환경에서 병행 처리할 수 있는지를 검토한다.
