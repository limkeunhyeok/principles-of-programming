# Chapter 3 사상-프로그래밍의 이데올로기

## 3.46 표현성의 원칙

### 정보는 데이터에 모아 표현

- 코드에서 정보를 표현할 때는 로직이 아닌 데이터에 모아 작성하는 방식으로 한다.
- 정보를 데이터에 고정시킴으로써 로직은 읽기 쉬워지고 안정된다.
- 자료구조를 활용하면 매우 복잡한 것이라도 간단히 모델링할 수 있고 더욱 간단히 표현을 할수도 있다.

### 데이터는 로직보다 다루기 쉽다

- 사람 입장에서 절차적인 로직은 쉽게 이해하기 힘들다.
- 자료구조는 복잡한 것이라도 비교적 쉽게 이해할 수 있다.
  - 데이터는 로직보다 다루기 쉽다.

### 복잡함을 데이터에 모은다

- 코드상에서 피할 수 없는 복잡한 부분이 있다면 데이터에 모으도록 한다.
- 로직과 자료구조 중에 선택해야 한다면 자료구조가 복잡해지는 쪽으로 한다.

## 3.47 충격 최소의 원칙

### 예상대로 동작하는 인터페이스

- 인터페이스는 사용하는 사람이 상상하는 형태대로 동작하도록 설계한다.
- 사용하는 사람의 충격이 최소가 되게끔 설계해야 한다.

### 학습 비용이 낮아진다

- 가장 쉽게 사용할 수 있는 소프트웨어란 사용자가 새롭게 배워야 하는 것이 가장 적은 소프트웨어다.
- 사용자가 애초에 가진 지식에 가장 효과적으로 연계될 수 있는 소프트웨어를 뜻한다.

### 사용자의 기존 지식을 활용한다

- 유사한 점이 많은 소프트웨어의 인터페이스를 모델로 삼는다.
- 예상 사용자의 특징을 고려한다.
- 전통에 주의를 기울인다.
- 언뜻 보면 비슷하지만 미묘하게 다른 상황을 피한다.

## 3.48 침묵의 원칙

### 소프트웨어는 과묵해야

- 소프트웨어는 표시를 최소한으로 줄이고 과묵하게 작업을 수행해야 한다.
- 반드시 알려야 하는 예상외의 상황이 아니라면 소프트웨어는 아무것도 말하지 않도록 한다.

### 중요한 정보를 전하기 쉽다

- 메시지 출력이 많으면 사용자는 자기 관점에서 중요한 정보가 무엇인지를 알 수 없다.
- 표시를 엄선하는 과정을 거쳐 모두 중요한 정보만 표시된다면 사용자는 정보를 구분 지을 필요가 없다.
- 꼭 필요할 때 이외에는 사용되어서는 안된다.

### 중요한 정보만을 표시하여 출력

- 실제로 발생한 오류만을 표준 오류 출력으로 표시하고 그 밖에 요구되지 않은 데이터는 일체 출력하지 않도록 한다.
- 디버깅 목적으로 진행 상황에 관해 메시지를 표시하고 싶다면 장황하게 switch 문을 만들고, 일반적인 상황에서는 사용되지 않게 비활성화 한다.

## 3.49 복구의 원칙

### 복구 실패시는 처리 정지

- 소프트웨어 동작 중 오류 복구에 실패했다면 처리를 계속해서는 안 된다.
- 소프트웨어의 동작은 평상시뿐만 아니라 실패시에도 투명해야 한다.

### 오류시 계속되는 실행은 피해 확대

- 복구에 성공하지 못했는데도 처리를 계속하면 오류 발생 시의 시나리오로서는 최악의 상황에 빠진다.

### 오류 통지는 요란하게

- 오류가 발생했을 때는 가능하면 조기에 요란하게 통지하도록 한다.
- 소프트웨어가 스스로 회복할 수 없을 때는 무리해서 계속 처리하지 말고 사용자가 빨리 알아차리게끔 만들어서 사용자의 판단을 받는 것이 중요하다.

### 소프트웨어 입출력에 관한 금언

- 입력에 관해서는 잘못된 형식이라도 가능한 적절한 의미를 끄집어내서 관용적으로 받아들여야 하고, 출력에 관해서는 엄밀히 따져 명료하고도 정확한 데이터를 송출해야 한다.

## 3.50 경제성의 원칙

### 프로그래머의 시간을 소중히

- 다음과 같은 문제가 프로그래머의 시간을 낭비하게 만든다.
  - 빈약한 하드웨어
  - 사용 소프트웨어에 대한 제한
  - 환경에 관한 규제와 제한

### 프로그래머의 시간은 귀중

- 설비에 투자해서 프로그래머가 효율적이면서도 기분 좋게 업무를 할 수 있다면 투자는 쉽게 회수할 수 있다.

### 프로그래머에게 투자한다

- 설비에 투자하는 형태로 간접적으로 프로그래머에게 투자한다면 수지는 분명 플러스가 된다.
- 개발 효과가 높아지고 스트레스는 내려가므로 생산성과 품질이 매우 향상될 것이다.

## 3.51 생성의 원칙

### 코드를 작성하는 코드를 작성한다

- 코드를 생성하는 코드를 작성한다.
- 수작업을 피하고 코드를 작성하기 위한 코드를 작성하도록 한다.

### 생성된 코드는 값싸고 고품질

- 코드에 대한 수동적인 단순 작업은 인간의 감각을 마비시켜 지연이나 실수의 원인이 된다.
- 생성된 코드는 프로그래머가 손으로 작성한 코드보다 항상 싸게 먹히면서도 고품질이다.

### 코드 생성기를 만든다

- 코드 생성기를 적재적소에 작성한다.
- 반복이 많고 정형적인 코드는 코드 생성기의 대상으로 한다.

## 3.52 최적화의 원칙

### 빠른 코드보다 바른 코드

- 프로그래밍에서 최적화란 성능 튜닝을 뜻한다.
  - 동작 속도를 높이고 메모리나 디스크 공간 등 머신 자원의 사용을 효율화하는 작업이다.
- 프로그래밍에서는 코드를 최적화하기 전에 바르게 동작하는 코드를 작성하도록 한다.

### 조기의 빠른 코드는 설계를 파탄 나게 만든다

- 최적화에 집착하면 다음과 같은 문제가 발생한다.
  - 투명성이나 단순성이 희생된다.
  - 부분적인 어중간한 최적화가 전체의 최적화를 방해한다.

### 바르게 만든 다음에 빠르게 만든다

- 먼저 바른 코드를 만든 다음에 빠르게 만든다.
- 코드의 단순한 상태를 유지하고, 다음에 체계적으로 찾아 최적화를 수행한다.

### 프로토타입으로 최적화

- 프로토타입을 사용하면 코드를 작성하지 않아도 되는 기능이 파악된다.
- 코드를 작성하지 않는 것은 성능을 올리는 데 기여한다.

## 3.53 다양성의 원칙

### 선택의 다양성을 수용한다

- 소프트웨어에서는 선택의 다양성을 수용한다.
- 유일하게 바른 방법은 존재하지 않는다.

### 인간의 상상력에는 한계가 있다

- 모든 면에서 최적인 것을 만들 수 있는 사람일지라도 모든 용도까지 예측하기란 불가능하다.

### 더 좋은 방식을 계속 찾는다

- 다양성을 인정해서 사고를 멈추지 말고 더 좋은 방식을 계속 모색한다.
- 단 한 번의 배포로 사용자의 모든 요구에 완벽하게 대응할 수는 없다.

## 3.54 확장성의 원칙

### 확장할 수 있게 설계한다

- 확장성을 고려한 설계를 수행한다.
- 코드에는 성장의 여지를 남겨 둔다.

### 소프트웨어는 성장해야 한다

- 확장성을 미리 고려하지 않으면 호환성을 유지하면서 코드를 바꿔 작성할 수 없다.
- 최초의 설계가 누락 없이 완벽할 수는 없다.

### 연결 가능한 설계

- 소프트웨어가 연결 가능(pluggable)하도록 설계해야 한다.
- 확장을 위한 연결부를 유연하게 만들어 코드 안에 주석을 달아 둔다.

### 자기 설명적인 데이터 형식

- 확장성의 원칙은 데이터 형식(데이터 레이아웃, 데이터 포맷)에도 적용된다.
- 프로토콜이나 파일 형식을 설계할 때는 자기 설명적으로 만들어 확장할 수 있도록 한다.
