# Chapter 3 사상-프로그래밍의 이데올로기

## 3-11 아키텍처 기본 기법

### 좋은 코드의 기초 원리

- 추상
- 캡슐화
- 정보 은닉
- 패키지화
- 관심의 분리
- 충족성, 완전성, 프리미티브성(원시성, 순수성)
- 정책과 구현의 분리
- 인터페이스와 구현의 분리
- 참조의 단일성
- 분할 정복

### 좋은 코드에는 품새가 있다

- 제대로 소프트웨어 아키텍처를 구축하려면 기초가 되는 몇 가지 원리에 기반을 두고 수행해야 한다.

### 품새(패턴)를 익힌다

- 기본 기법은 특정 소프트웨어 기술에서 도출된 것이 아닌 더욱 기본적이고 본질적인 해법이다.
- 개발 방법론이나 프로그래밍 언어와 관계없이 적용할 수 있다.

## 3.12 추상

### 개념적인 선 긋기

- 추상이란 개념적으로 명확한 선 긋기를 수행하는 것이다.
- 추상은 사상과 일반화라는 2가지 관점에서 정리된다.
  - 사상: 복잡한 대상의 몇 가지 성질을 버리고 특정한 성질에 주목하는 것이다.
  - 일반화: 구체적인 대상으로부터 공통 성질을 추출해서 더욱 범용적인 개념으로 정식화하는 것이다.

### 복잡함에 대한 대항 수단

- 사상은 부차적인 부분을 제거해 대상물의 본질을 드러낸다.
- 일반화는 여러 가지 사항을 공통된 성질에 따라 그룹핑해서 같다고 간주하는 것이다.

### 사상과 일반화를 구사

- 추상화는 뛰어난 아키텍처를 구축하기 위해 필요한 프로그래머의 기초 기술이다.
- 복잡한 대상에 집중할 때는 사상한다.
- 다른 여러 개의 대상에 집중할 때는 일반화한다.

## 3.13 캡슐화

### 데이터와 로직을 그룹핑

- 관련 있는 데이터와 로직을 그룹핑해서 하나의 모듈을 정의한다.
- 관계성이 강한 데이터와 로직을 모듈이라는 껍질로 감싸는 것을 캡슐화라고 부른다.

### 추상 개념이 섞이지 않는다

- 관련 없는 요소가 섞이지 않기 때문에 코드가 읽기 쉬워진다.
- 변경 시의 영향이 모듈 안으로 한정된다.
- 영향도가 명확해지므로 코드의 변경이 쉬워진다.
- 각각 독립된 부품이므로 재사용성이 높아진다.
- 작은 단위로 분할되므로 복잡한 문제에 대처할 수 있다.

### 같은 부류의 요소를 캡슐에 담는다

- 관련 있는 요소만을 모듈에 넣으면, 관계성이 강한 데이터로부터 생성된 자료구조와 관계성이 강한 로직으로부터 만들어진 함수를 포함한, 순수하면서 질이 좋은 모듈이 만들어진다.

## 3.14 정보 은닉

### 필요 없는 것을 보여주지 않는다

- 모듈의 구현을 해당 모듈을 사용하는 클라이언트로부터 은닉한다.
- 모듈에 어떤 형태로 데이터가 있으며 함수가 어떤 로직으로 기능을 실현하는 지를 외부로부터 은닉한다.
- 모듈의 데이터는 외부에서 직접 접근할 수 없도록 하며, 모듈의 함수는 최대한 비공개로 한다.
- 클라이언트에서는 모듈로부터 최소한으로 공개된 함수를 통해서만 조작할 수 있다.

### 관련을 정리해서 단순하게

- 모듈이 클라이언트가 알 필요 없는 내부의 상세 부분을 은닉하면 인터페이스가 작아지고 정보의 교환이 단순해지며 코드 전체의 복잡성을 낮출 수 있다.
- 클라이언트에서 봐도 불필요한 정보가 보이지 않기 때문에 모듈의 사용법이 단순해지고 사용성이 좋아진다.
- 공개 부분이 작으면 모듈 내부에서 변경이 끝날 가능성이 커진다.
  - 이렇게 함으로써 코드 변경의 파급을 최소한으로 억제할 수 있다.

### 내부는 은닉한다

- 모듈 내부의 데이터나 모듈 내부에서만 사용하는 함수는 외부에서 접근할 수 없도록 해 둔다.
- 정보 은닉을 실현하려면 캡슐화를 사용한다.

### 캡슐화와 정보 은닉의 차이

- 캡슐화
  - 관계가 있는 요소를 모아 모듈화하는 것이다.
  - 관계가 깊은 데이터와 함수를 한군데로 모은다.
- 정보 은닉
  - 모듈의 내부 상태나 내부 함수를 은닉하는 것이다.
  - 내부에 대한 외부로부터의 직접적인 접근을 차단한다.
- 넓은 의미에서 캡슐화도 일반적으로 사용된다.
  - 따라서 어느 쪽의 의미로 사용되고 있는지 문맥을 잘 따져볼 필요가 있다.

### 파르나스의 규칙

- 모듈의 사용자에게는 해당 모듈을 사용하는 데 필요한 모든 정보를 주고 그 이외의 정보는 일체 보여주지 않는 것
- 모듈의 작성자에게는 해당 모듈을 구현하는 데 필요한 모든 정보를 주고 그 이외의 정보는 일체 보여주지 않는 것

## 3.15 패키지화

### 모듈을 그룹핑

- 모듈을 의미 있는 단위로 모은 다음 그룹화하고, 이렇게 분할된 단위를 패키지라고 한다.
- 패키지는 소프트웨어의 논리 구조를 물리 구조에 저장하는 방법을 결정한다.

### 모듈의 복잡도를 낮춘다

- 코드의 관련 요소를 캡슐화하여 모듈을 작성하면 코드가 정리되고 복잡도가 낮아진다.
  - 하지만 대규모 소프트웨어가 되면 대량으로 작성된 모듈이 오히려 복잡성을 낳는 결과를 초래한다.
- 패키지화는 다음과 같은 이점이 있다.
  - 소프트웨어 전체가 패키지라는 작은 단위로 분할되므로 복잡도가 낮아진다.
  - 패키지 안에 관련 없은 모듈이 섞이지 않으므로 모듈을 관리하기 쉬워진다.
  - 수정에 대한 영향도가 패키지 안에 머무를 가능성이 높으므로 코드를 변경하기 쉬워진다.
  - 종속 관계가 정리되어 패키지 단위로 재사용하기 쉬워진다.

### 상향식으로 패키지 설계

- 패키지 설계는 모듈이 어느 정도 만들어진 다음에 상향식으로 설계한다.
- 개발이 진행되다 보면 모듈이 점점 늘어난다.

## 3.16 관심의 분리

### 관심별로 코드를 분리

- 관심이란 소프트웨어의 기능이나 목적을 뜻한다.
- 관심을 분리한다는 것은 각각의 관심에 관련된 코드를 모아 독립된 모듈로 만들어 다른 코드로부터 분리한다는 뜻이다.

### 관심 단위로 변경이 이루어진다

- 관심별 분리의 이점
  - 관심별로 독립해서 수정할 수 있으므로 읽는 범위가 한정되고 변경이 쉬워진다.
  - 영향 범위가 관심 안에 머무르므로 변경 시 품질이 안정된다.
  - 코드를 작성할 때는 관심 단위로 개발하므로 분업, 병행하여 개발을 진행할 수 있다.

### 관심 단위로 모듈화

- 관심별로 모듈을 작성하여 서로 다른 책임이나 관계없는 책임은 분리해 둔다.

### 관점 지향 프로그래밍

- 관점 지향 프로그래밍(AOP: Aspect-Oriented Programming)은 관심 중에서도 횡단적 관심을 분리한 기술이다.
- 횡단적 관심이란 각 관심을 옆쪽에서 꼬챙이로 꿰는 듯한 관심을 뜻한다.
- 일반적으로 횡단적 관심은 분리되지 않은 상태로 각 기능에 산재해 있는데, 이는 코드의 변경을 방해하는 커다란 요인이다.

## 3.17 충족성, 완전성, 프리미티브성

### 표현이 충분하고 완벽하면서 순수함

- 충족성
  - 모듈이 표현하고자 하는 추상이 그것을 전하기에 충분한지를 뜻한다.
- 완전성
  - 모듈이 표현하고자 하는 추상이 모든 특징을 갖추고 있는지를 뜻한다.
- 프리미티브성
  - 모듈이 표현하고 하는 추상이 모두 순수한지 아닌지를 의미한다.

### 표현하고 있는 추상을 정확히 전한다

- 모듈이 표현하고자 하는 추상은 의도가 사용하는 사람에게 전해져야 하고, 유용해야 한다.
- 모듈이 충분하지 않으면 정보가 부족해서 클라이언트는 모듈의 본질을 놓친다.
- 모듈이 완전하지 않으면 클라이언트가 안심하고 사용할 수 없다.
- 모듈이 프리미티브하지 않으면 클라이언트가 모듈을 사용하기 어려워진다.

### 모듈의 추상을 빈틈없이 표현

- 정보는 너무 많아도 너무 적어도 전달되지 않는다.
- 모듈이 제공하는 함수는 충분하고 완전하며 순수한 라인업이어야 한다.

## 3.18 정책과 구현의 분리

### 정책과 구현은 섞지 않는다

- 정책 모듈
  - 해당 소프트웨어의 전체에 종속되는 비즈니스 로직이다.
- 구현 모듈
  - 해당 소프트웨어의 전제에 종속되지 않는 독립된 로직 부분이다.

### 구현은 안정적이지만 정책은 불안정

- 구현 모듈은 특정 소프트웨어에 종속되지 않는 순수한 모듈이므로 다른 소프트웨어에서도 재사용할 수 있다.
- 정책 모듈은 해당 소프트웨어에 특화더이 있어, 해당 소프트웨어가 변경되면 정책 모듈은 변경을 강요당한다.

### 정책과 구현은 별개 모듈로

- 소프트웨어의 전제체 종속되는 부분인 정책과 종속되지 않는 부분인 구현을 의식해서 설계한다.
- 분리할 수 없을 때 적어도 모듈 내에서 정책 부분과 구현 부분을 명확히 알 수 있도록 표현해 두어야 한다.

## 3.19 인터페이스와 구현의 분리

### 구성은 인터페이스와 구현으로

- 인터페이스 파트
  - 모듈이 가진 기능을 정의하고 모듈의 사용방법을 정하는 부분이다.
- 구현 파트
  - 모듈이 가진 기능을 실현하는 코드 부분이다.

### 사용자는 인터페이스만 알면 된다

- 인터페이스와 구현이 분리되면 모듈을 사용하는 클라이언트는 구현에 대한 상세를 알 필요가 없어진다.
- 인터페이스와 구현이 분리되면 클라이언트에서의 사용법(=인터페이스)과 기능의 실현 방법(=구현)이 서로 독립성을 확보할 수 있다.

### 인터페이스를 사용해서 설계한다

- 모듈에 관한 설계 원리로 구현이 아닌 인터페이스에 맞춰 프로그래밍 한다.
