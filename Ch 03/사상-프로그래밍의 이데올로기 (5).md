# Chapter 3 사상-프로그래밍의 이데올로기

## 3.22 아키텍처 비기능 요구사항

### 기능 외적인 기능이라는 관점

- 비기능 요구사항이란 기능 외적인 면 전반에 관한 요구사항을 뜻한다.
- 비기능 요구사항 관점
  - 변경 용이성
  - 상호 운용성
  - 효율성
  - 신뢰성
  - 테스트 용이성
  - 재사용성

### 비기능은 배포 후에 큰 영향

- 비기능적인 특성은 개발이나 유지보수, 운용, 컴퓨터 리소스의 효율적 활용에 커다란 영향을 미친다.

### 비기능 관점에서 설계

- 요구사항을 정의할 때는 각각의 관점이 어느 정도 필요해 질지를 확인한다.
- 개발할 때는 아키텍처 설계 시점에 비기능 요구사항을 고려한 구조를 고민한다.
- 테스트할 때는 비기능 요구사항을 충족하고 있는지를 확인한다.

### 비기능 테스트

- 기능 테스트는 무엇을 하는지, what에 주목한다.
- 비기능 테스트는 어떻게 동작하는지, how에 주목한다.
- 비기능 요구사항을 충족하려면 해당 소프트웨어에 최적인 비기능 요구사항 수준을 판별한 후에 비기능 테스트에도 합격 기준을 마련하는 것이 필요하다.

### 보안 비기능 요구사항

- 정보 보안이란 쉽게 말해 소프트웨어가 다루는 정보 자산을 부정한 접근이나 유출, 조작으로부터 지키고 언제라도 사용 가능한 상태로 만들어 두는 것이다.
- 정보 보안의 3대 요소
  - 기밀성(Confidentiality)
  - 무결성(Integrity)
  - 가용성(Availability)

#### 기밀성

- 인가되지 않은 개인, 엔티티, 프로세스에 대해 정보를 사용 불가 또는 비공개로 하는 특성으로 정의된다.
- 허가되지 않은 사람이 정보를 사용하지 못하게 만드는 것이다.

#### 무결성

- 자산의 정확함과 완전함을 보호하는 특성으로 정의된다.

#### 가용성

- 인가된 개체가 요구했을 때 접근 및 사용이 가능한 특성으로 정의된다.
- 원할 때 정보에 접근할 수 있고 이용할 수 있어야 한다.
- 조직 입장에서 유지하고 있는 중요한 정보에 언제라도 확실히 접근할 수 있어야 한다는 점은 필수 사항이다.

### 보안 검증

- 보안 검증에서는 우선 모의 침투 테스트(penetration test)를 수행한다.
- 모의 침투 테스트란 보안 취약성을 찾아내기 위해 소프트웨어를 실제로 공격해서 침입을 시도해보는 검증 기법이다.
- 보안 검증에서는 보안 사고 발생 시의 추적 가능성 및 감사 능력의 평가도 요구된다.
- 보안 대책으로 인해 소프트웨어 편의성에 영향을 미치지는 않는지 신경을 써야 한다.

## 3.23 변경 용이성

### 코드를 쉽게 변경하는 능력

- 변경 용이성이란 해당 소프트웨어를 얼마나 쉽게 개선할 수 있는지에 대한 능력을 뜻한다.
- 해당 소프트웨어를 쉽게 수정할 수 있는지, 쉽게 확장할 수 있는지, 쉽게 재조작할 수 있는지, 쉽게 다른 플랫폼으로 이식할 수 있는지 등의 능력을 뜻한다.

### 소프트웨어의 수명은 의외로 길다

- 소프트웨어가 처음 배포된 채 그대로 사용되는 경우는 일단 없다.
- 소프트웨어 이용 기간 중에 끊임없이 변경과 확장이 이루어지며, 기존의 요구사항은 변경되고 새로운 요구 사항이 추가된다.

### 보수성, 확장성, 재구축, 이식성

- 보수성
  - 보수성이란 문제점의 해결, 다시 말해 오류가 발생한 코드의 수정이 용이함을 뜻한다.
  - 보수성을 높이려면 변경을 국소화해서 다른 모듈에 부작용이 미치는 것을 최소화하는 아키텍처를 채택한다.
- 확장성
  - 확장성이란 신규 기능 추가, 신규 버전으로 모듈 교체, 불필요한 기능이나 모듈의 제거 등과 같은 작업의 용이함을 가리킨다.
  - 확장성을 가지려면 모듈 간의 결합도가 약해야 한다.
  - 확장성이 지향하는 목표는 클라이언트에 영향을 미치지 않고 모듈의 교환이 가능한 구조다.
  - 기존 아키텍처에 새로운 모듈을 통합할 수 있는 구조도 필수적이다.
- 재구축
  - 재구축이란 모듈 간 관계의 재조직화를 수행하는 것이다.
  - 모듈이 다른 서브 시스템으로 이동하는 등 위치를 변경할 때 재구축이 필요하다.
  - 재구축을 쉽게 수행하려면 모듈의 구현에는 영향을 미치지 않고, 모듈을 유연하게 배치할 수 있는 구조를 만들어 둘 필요가 있다.
- 이식성
  - 이식성이란 소프트웨어를 다양한 하드웨어 플랫폼, 사용자 인터페이스, 운영체제, 프로그래밍 언어, 컴파일러 등에 적합하게 만들 때의 용이함을 뜻한다.
  - 이식성을 높이려면 하드웨어 종속성을 고려하면서 소프트웨어를 설계할 필요가 있다.

### 유연성의 배치 장소

- 좋은 아키텍처 설계에서 핵심은 소프트웨어의 어느 부분이 변경에 대해 높은 유연성을 지녀야 하는지, 반대로 변경이 발생하지 않는 부분은 어디인지를 파악하는 것이다.
- 유연성을 지녀야 할 부분은 변경을 고려한 설계를 지원하는 패턴을 사용함으로써 유연성을 높여 둔다.

### 소프트웨어 에이징

- 사람이 나이를 먹듯 소프트웨어도 나이를 먹는데 이를 소프트웨어 에이징(노후화)라고 한다.
  - 이는 시간이 지날수록 자연스럽게 성능이 떨어진다는 사고방식이다.
- 소프트웨어 에이징의 원인
  - 설계에 유연성이 없으므로 변경때문에 아키텍처가 파괴된다.
  - 설계가 좋다고 해도 설계를 이해하지 못하는 사람이 변경해서 아키텍처가 파괴된다.
  - 아키텍처를 이해하기가 어렵다는 이유로 무질서하게 변경이 이루어져 아키텍처가 파괴된다.
  - 업데이트가 이루어지지 않거나 시대에 뒤처져 진부해지고 만다.

## 3.24 상호 운용성

### 다른 소프트웨어와 대화하는 능력

- 상호 운영성이란 소프트웨어가 다른 소프트웨어와 정보를 주고받을 수 있는 능력을 뜻한다.

### 소프트웨어는 연계된다

- 소프트웨어는 시스템의 일부이며 독립해서 존재하는 것이 아니며, 다른 시스템이나 환경과 빈번하게 상호 작용한다.
- 다른 소프트웨어와 연결할 수 있다는 것은 기존 자산을 그대로 활용할 수 있다는 뜻이다.
  - 신규로 개발할 소프트웨어가 줄어든다는 효과도 있다.

### 표준 규격을 선택한다

- 외부 기능이나 자료구조로의 접근이 명확하게 정의된 아키텍처를 설계한다.
- 연결의 용이성은 소프트웨어의 가치를 높인다.
- 표준에 근거하면 소프트웨어의 가치는 지속된다.

## 3.25 효율성

### 리소스를 잘 사용하는 능력

- 효율성이란 소프트웨어가 실행되면서 동반되는 리소스 사용에 있어서 적절한 성능을 끌어내는 능력을 뜻한다.
- 시간 효율성
  - 시간이라는 관점에서 리소스의 사용 효율을 정의한다.
  - 일정 시간 내에 처리를 몇 건 끝낼 수 있는지를 뜻하는 처리율(throughput), 사용자의 입력 조작부터 응답까지 걸리는 시간인 응답 시간(response time), 사용자의 작업 개시로부터 요구 받은 정보의 출력을 끝내기까지 걸리는 시간인 소요 시간(turnaround time) 등으로 계측한다.
- 자원 효율성
  - 컴퓨터 자원이라는 관점에서 리소스의 사용 효율을 정의한다.
  - CPU 사용 시간이나 메모리 사용량, 스토리지 소비량, 네트워크 전송량 등으로 계측한다.

### 리소스는 한정적이다

- 리소스는 한정적이기 때문에 소프트웨어는 리소스를 효율적으로 이용할 필요가 있다.
- 리소스를 제대로 사용하지 않으면 소프트웨어의 동작이 느려지고 사용자의 사용성도 나빠진다.
- 효율성을 실현하려면 아키텍처 설계 단계에서 모듈에 대한 역할을 분산하고 해당 모듈들 사이를 적절히 결합할 필요가 있다.

### 리소스를 적극적으로 활용한다

- 적절한 이용이란 리소스를 사용하지 않는다는 말이 아니다.
- 절약하는 것도 필요하지만, 활용한다는 관점으로도 아키텍처를 설계해야 한다.

### 간접화와 효율성의 균형

- 모듈 가느이 직접 결합을 피하려고 모듈들 사이에 매개 모듈을 도입하는데, 이를 간접화라고 한다.
- 간접화는 기초적이면서 적용 범위가 넓은 모듈을 설계하는 방법이다.
- 간접화를 통해 느슨한 결합성을 유지하고 높은 보수성과 확장성, 재사용성을 확보할 수 있다.
- 간접화를 도입할 때는 효율성과의 균형을 고려해야 한다.

## 3.26 신뢰성

### 기능을 유지하는 능력

- 신뢰성이란 소프트웨어가 예외적인 상황 혹은 예기치 못한 방법이나 부정한 방법으로 사용된 상황에서도 기능을 유지하는 능력을 뜻한다.
- 결함 허용력(fault tolerance)
  - 소프트웨어에 장애가 발생했을 때 정상적인 동작을 계속 유지하는 능력이다.
  - 예외 발생에 대해서 올바른 행위를 보증하는 한편 내부적으로는 복구를 실시한다.
- 견고성(robustness)
  - 부정한 사용 방법이나 입력 실수로부터 소프트웨어를 보호하는 능력이다.
  - 갖가지 사용 방법에 대해 시스템 차원에서 정의된 상태로 이행한다.

### 요구되는 기능 유지 수준이 다양

- 소프트웨어마다 요구되는 신뢰성은 다르다.
- 요구사항을 미리 명확히 하고 그에 따라 아키텍처를 설계해야 한다.

### 중복(redundancy), 장애 완화(fail soft), 장애 시 안전(fail safe)

- 결함 허용력 관점의 대책으로 아키텍처 내부에 중복(이중화 등)을 갖게 한다.
- 장애 발생 시에는 제공하는 기능을 한정하고 중요한 기능만을 제공해서 처리의 지속성을 우선시하는 설계(fail soft)도 고려한다.
- 견고성 관점의 대책으로 장애 발생 시에 해당 부분을 분리하는 설계(fail safe)를 검토한다.
- 애초에 장애가 발생하지 않도록 미리 사용자가 잘못된 조작을 해도 안전하게 가동할 수 있는 설계(fool proof)도 고려한다.

## 3.27 테스트 용이성

### 효과적으로 테스트하는 능력

- 테스트 용이성이란 소프트웨어에 대해 효과적이면서 효율적으로 테스트를 수행하는 능력을 뜻한다.
- 테스트가 효과적이라는 말은 테스트가 깊이 있고 질이 높다는 뜻이다.
- 테스트가 효율적이라는 말은 테스트의 비용이나 노력이 적은 것을 가리킨다.

### 테스트의 품질이 본체의 품질

- 소프트웨어의 규모와 복잡성이 증가할수록 테스트는 더욱 난해해지고 비용이 많이 든다.
- 개발 단계에서든 유지보수 단계에서든 수정한 소프트웨어의 품질을 담보한다는 것은 보편적으로 중요한 과제이다.
- 소프트웨어의 검증을 쉽게 하려면 아키텍처 차원의 지원이 필요하다.

### 테스트를 고려한 본체 설계

- 아키텍처 확정 시점부터 검증 방법에 대한 관점을 포함해서 설계한다.
- 테스트 용이성을 설계할 때는 모듈 간 종속 관계를 제거하는 것이 핵심이다.

## 3.28 재사용성

### 재사용하고 재사용되는 능력

- 재사용성이란 소프트웨어를 전체가 됐든 일부가 됐든 다른 소프트웨어 개발에 재사용하는 능력을 뜻한다.
- 재사용하는 소프트웨어 개발
  - 프로젝트 내의 기존 모듈, 예전 프로젝트의 모듈, 각종 라이브러리 등을 이용하는 것을 의미한다.
  - 재사용 가능한 모듈을 개발 중인 소프트웨어에 그대로 혹은 변형해서 통합한다.
- 재사용을 위한 소프트웨어 개발
  - 장래의 프로젝트에서 재사용할 수 있는 모듈을 현재 소프트웨어 개발 과정에서 창출하는 것을 의미한다.
  - 다른 소프트웨어에서 재사용하기 위한 소프트웨어를 개발한다.

### 최대한 만들지 않음으로써 개발 효율화

- 소프트웨어를 효율적으로 개발하고 소프트웨어의 품질을 높이려면 가능한 한 만들지 않아야 한다.
  - 즉, 어딘가에서 빌려 오는 방법이 가장 좋다.
- 재사용하면 만들 분량이 줄어들고 소프트웨어 개발 비용과 기간이 줄어든다.

### 플러그인 아키텍처

- 재사용하는 소프트웨어를 개발할 때는 아키텍처의 구성을 기존 구조나 모듈에 플러그인할 수 있도록 한다.
- 소프트웨어 컴포지션이란 소프트웨어를 기존 모듈을 가지고 조립하는 것이다.
- 재사용을 위한 소프트웨어를 개발할 때는 개발 중인 소프트웨어에서 자기충족적인 부분을 떼어 낼 수 있는 아키텍처로 한다.

### 재사용 가능한 모듈의 3의 법칙

- 난이도 3배 법칙
  - 재사용 가능한 모듈을 만드는 작업은 단일 소프트웨어에서 사용할 모듈을 개발할 때보다 3배 어렵다는 법칙이다.
  - 재사용 가능한 모듈을 만드는 프로그래머는 일반화된 문제를 처리해야 한다.
- 테스트 3종류의 법칙
  - 재사용 가능한 모듈은 공유하기 전에 3가지의 다른 소프트웨어로 테스트할 필요가 있다는 법칙이다.
  - 재사용 가능한 모듈은 자신이 현재 당면한 문제를 해결하는 것만으로는 불충분하며 더 일반적인 문제도 해결할 수 있어야 한다.

### 탈착 가능한 컴포넌트인 프레임워크

- 같은 문제 영역에서 몇 가지 소프트웨어를 구현하다 보면 설계가 능숙해지고, 난관을 돌파한 경험을 통해 해당 문제 영역에 특화된 프레임워크를 설계할 수 있다.
- 프레임워크는 인터페이스가 정해져 있는 허브 같은 것으로서, 프레임워크에 문제 영역의 가변적인 부분을 컴포넌트로 탈착할 수 있다.
