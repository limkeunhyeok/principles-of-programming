# Chapter 4 관점-프로그래머가 보는 시각

## 4-1 응집도

### 모듈은 순수하게

- 응집도란 모듈에 포함된 기능의 순수함을 나타내는 척도로, 모듈의 강도를 측정하는 단위다.
- 응집도의 강도는 7단계로, 단계가 높을수록 순수하고 강하며 좋은 모듈이다.

#### 1단게: 암합적 강도

- 암합적 강도 모듈은 내 요소 간 특별한 관계가 인정되지 않는다.
- 모듈 내 중복된 명령의 패턴을 우연히 발견했다는 이유로 통합해서 하나의 모듈로 만든 경우다.
- 암합적 강도 모듈 내의 각 요소는 자기 모듈 내 다른 요소와의 관련성은 약하면서도 다른 모듈 내 요소와는 강한 관련을 갖는 경향이 있다.

#### 2단계: 논리적 강도

- 논리적 강도 모듈은 어떤 기능을 추상적으로 파악해서 모은 것이다.
- 기능을 추상적으로 파악한다는 것은 모든 입출력 조작을 모아서 모듈화하거나 여러 가지 데이터를 편집하기 위한 모듈을 작성한 경우다.

#### 3단계: 시간적 강도

- 시간적 강도 모듈은 특정 시점에 연속해서 실행되는 여러 개의 기능을 하나의 모듈로 모은 것이다.
- 기능 사이에 그다지 강한 관련성은 없으며, 특정 시점에 연속해서 실행될 뿐이다.

#### 4단계: 순서적 강도

- 순서적 강도 모듈은 문제를 처리하기 위해 관계된 여러 개의 기능 중 몇 가지를 실행한다.
- 커다란 기능의 일부 순서를 하나의 모듈로 만들었다면 순서적 강도이며, 순서도의 일부를 모듈화한 경우 등이 여기에 해당한다.

#### 5단계: 연락적 강도

- 연락적 강도 모듈은 기본적으로 순서적 강도의 특성을 갖는다.
- 순서적 강도와의 차이점은 모듈 내 기능 사이에서 데이터를 교환(연락)하거나 같은 데이터를 참조한다는 점이다.

#### 6단계: 정보적 강도

- 정보적 강도 모듈은 특정 자료구조를 다루는 여러 개의 기능을 하나의 모듈로 모은 것이다.
- 같은 자료구조(정보)는 가능한 한 특정 모듈에서만 접근하도록 한다.
- 정보적 강도 모듈은 진입점을 여러 개 가지며 각 진입점은 단일한 고유 기능을 실행한다.

#### 7단계: 기능적 강도

- 기능적 강도 모듈은 모듈 내의 모든 명령이 하나의 역할(기능)을 실행하기 위해 서로 관련된 모듈로, 응집도가 가장 높은 모듈이다.
- 기능적 강도를 갖는 모듈의 변경은 해당 모듈만으로 처리할 수 있으며, 다른 모듈에 미치는 영향도는 다른 강도의 영향도보다 작다.

### 섞여 있는 모듈은 깨지기 쉽다

- 코드는 모듈로 분할함으로써 통제가 가능해진다.
- 분할된 모듈은 톡립성이 중요하다.
  - 독립성은 코드의 복잡함을 감소시키고 결과적으로 코드의 신뢰성을 높이며 유지보수하기 쉽게 만든다.
- 응집도가 낮은 모듈의 문제
  - 코드를 이해하기 어렵다.
  - 코드를 유지보수하기 어렵다.
  - 코드를 재사용하기 어렵다.
  - 코드가 취약하며 변경에 따른 영향을 끊임없이 받는다.
- 응집도가 높은 모듈의 장점
  - 코드 설계의 명확함과 이해도가 높아진다.
  - 코드의 유지보수와 확장이 쉽다.
  - 코드의 재사용성이 촉진된다.
  - 모듈 간의 소결합성도 동시에 촉진된다.

### 고강도 모듈을 지향한다

- 모듈의 독립성을 높이려면 가능한 한 기능적 강도 모듈을 지향한다.

## 4.2 결합도

### 모듈 간의 소원하게

- 결합도란 모듈끼리 갖는 관계의 밀접함을 나타내는 척도로, 어떤 결합의 굵기를 측정하는 단위다.
- 결합도의 수준은 6단계로, 단계가 높을수록 관계가 약하고 느슨한 결합이며 좋은 모듈이라고 할 수 있다.

#### 1단계: 내용 결합

- 내용 결합이란 한 모듈과 다른 모듈이 일부를 공유하는 모듈 결합 방식이다.
- 다른 모듈 내의 외부에 선언되지 않은 데이터를 직접 참조하거나 명령의 일부를 공유하는 경우가 여기에 해당한다.
- 내용 결합은 한쪽 모듈의 변경이 다른 모듈에 영향을 미친다.

#### 2단계: 공통 결합

- 공통 결합이란 공통 영역에 정의된 데이터를 몇 개 모듈이 공동으로 사용하는 모듈 결합 방식이다.
- 공통 영역에 정의된 데이터란 전역 변수를 말한다.
- 공통 결합의 단점
  - 공통 영역 데이터는 모듈 간의 인터페이스상에 나타나지 않으므로 코드 해독을 매우 어렵게 만든다.
  - 공통 영역 데이터는 원래 해당 데이터와 관계가 없는 모듈에서도 마음만 먹으면 사용할 수 있으므로 코드의 안정성이 낮아진다.
  - 공통 결합된 모듈은 공통 영역 데이터를 통해 여러 가지 모듈과 이어져 있으므로 재사용성이 저해된다.

#### 3단계: 외부 결합

- 외부 결합이란 외부에 선언된 데이터를 공유하는 모듈 결합 방식이다.
- 외부에 선언된 데이터란 public으로 선언된 변수를 말한다.

#### 4단계: 제어 결합

- 제어 결합이란 호출하는 모듈 쪽에서 호출받는 모듈의 제어를 지시하는 데이터를 파라미터로 넘겨주는 모듈 결합 방식이다.
- 제어 결합에서는 파라미터의 하나로 switch 변수를 넘겨주면서 호출받는 모듈이 그때 수행할 기능을 지시한다.

#### 5단계: 스탬프 결합

- 스탬프 결합이란 공통 영역에 없는 자료구조를 2개의 모듈에서 교환하는 모듈 결합 방식이다.
- 자료구조의 교환은 파라미터를 매개로 수행한다.

#### 6단계: 데이터 결합

- 데이터 결합이란 모듈 간의 인터페이스로 스칼라형 데이터 요소만을 파라미터로 교환하는 모듈 결합 방식이다.
- 상대 모듈을 블래박스화할 수 있으므로 결합도는 가장 약하다.

### 상호 종속되는 모듈은 깨지기 쉽다

- 결합이 밀접한 모듈은 서로 종속되며 영향을 미치므로 여러 가지 문제가 생긴다.
- 모듈을 사용하려면 해당 모듈이 종속되고 있는 모듈도 필요하므로 재사용하기 어렵다.

### 저결합 모듈을 지향한다

- 모듈의 독립성을 높이려면 모듈 간의 인터페이스는 가능한 한 낮은 단계의 결합도를 지향한다.
- 데이터는 가능한 한 파라미터로 넘겨준다.
- 데이터는 가능한 한 전역 변수로 두지 않으며, 특정 시점에만 필요한 데이터라면 지역 변수로 두도록 한다.
- 넘겨주는 값에 따라 동작이 바뀌는 코드를 작성하지 않는다.

### 하이브리드 결합

- 샹황에 따라 하이브리드적으로 반환값이 달라지므로 함수를 사용하는 쪽에서 이를 의식하고 사용해야 한다.
- 하이브리드 결합은 결합도로는 다소 높다고 볼 수 있다.

### 결합의 개수와 방향

- 결합도에 관한 착안점은 결합의 강도와 굵기다.

### 멱등성과 안전성

#### 멱등성

- 멱등성이란 어떤 조작을 반복해서 수행해도 결과가 같은 것을 의미하는 수학 용어다.
- 같은 함수를 반복해서 호출해도 반드시 같은 결과를 얻을 수 있다.

#### 안전성

- 안전이란 조작 대상의 상태를 변화시키지 않는 것을 의미한다.
- 상태에 변화를 미치는 것을 부작용이라고 부르므로, 안전은 조작 대상의 상태에 부작용이 없는 것이라고 말할 수 있다.

## 4-3 직교성

### 코드는 독립시켜라

- 코드는 직교성을 충족해야 한다.
  - 코드 간에는 독립성과 분리성을 갖도록 만든다.
- 한쪽을 변경해도 다른 쪽에 영향을 주지 않는다면 해당 코드는 직교하고 있다.
- 직교하고 있는 코드는 변경에 강한 코드다.

### 직교 코드는 견고

#### 생산성 향상

- 변경이 국소화되므로 개발 기간과 테스트 기간을 단축할 수 있다.
- 코드가 소결합되므로 코드의 재사용이 촉진된다.

#### 위험 경감

- 문제가 생겼다해도 해당 부분을 격리할 수 있으므로 코드가 더 견고해진다.
- 종속이 적으므로 쉽게 테스트할 수 있고 검증하기 편하다.

### 코드의 계층화

- 모듈 간의 결합도를 최소화한다.
  - 불필요한 정보는 다른 모듈에 공개하지 말고, 다른 모듈의 구현에 의존하지 않도록 코드를 기술한다.
- 코드 간의 결합도를 최소화하는 데는 계층화라는 접근이 유효한 방법이다.
- 소프트웨어는 각각이 독립된 기능을 갖는 모듈들의 협업을 통해 이루어져야 한다.
- 모듈들은 계층별로 정리하고 계층별로 추상화한다.
- 계층화는 모듈 간의 관계를 정리한다.
  - 모듈 간의 종속이 연쇄 반응적으로, 지수함수적으로 폭등하는 위험을 줄일 수 있다.

### 계층화의 장단점

- 장점
  - 다른 계층을 잘 알지 못해도 하나의 계층을 전체로서 생각할 수 있다. 예를 들어 이더넷의 동작 방법을 몰라도 TCP 상에 있는 FTP 서비스를 구축하는 방법을 이해할 수 있다.
  - 다른 계층에 영향을 미치지 않고 대체 구현으로 계층을 교체할 수 있다. 예를 들어 FTP 서비스는 이더넷, PPP 또는 케이블 회사가 바뀌더라도 실행하는 데 지장이 없다.
  - 계층 간의 종속을 최소한으로 할 수 있다. 예를 들어 케이블 회사가 IP를 동작시키는 물리적인 전송 시스템을 변경하더라도 FTP 서비스를 수정할 필요는 없다.
  - 계층은 표준화에 적합하다. TCP/IP는 계층의 동작 방법을 정의하는 표준 통신 프로토콜이다.
  - 계층을 구축하면 다양한 고수준 서비스가 해당 계층을 사용할 수 있다. TCP/IP는 FTP, TELNET, SSH, HTTP에 의해 사용되고 있다. TCP/IP가 없다면 고수준 프로토콜은 독자적으로 저수준 프로토콜을 작성해야 한다.
- 약점
  - 계층 간에 변경이 연쇄적인 경우가 있다. 예를 들어, 데이터를 등록하는 소프트웨어의 사용자 인터페이스에 어떤 필드를 추가했을 때다. 해당 필드는 데이터베이스에 존재할 필요가 있으므로 사용자 인터페이스에서 데이터베이스까지의 모든 계층에 새 필드를 추가해야 한다.
  - 계층을 추가하면 성능이 나빠질 수 있다. 계층을 지날 때마다 데이터 형식을 변환할 필요가 있는데, 이때의 데이터 변환이 오버헤드가 된다.

### 릴레이션의 직교성

- 릴레이션의 직교성은 여러 릴레이션 간의 중복에 관한 개념으로, 프로그래밍으로 말하자면 직교성보다는 DRY 원칙에 가까운 사고방식이다.
- 정규화를 통해 각 릴레이션에서 중복이 해소되더라도 데이터베이스 전체적으로 봤을 때 중복이 남아 있다면 역시 불일치의 원인이 된다.

### 릴레이션의 정의

- 관계 데이터 모델에서 릴레이션이란 SQL에서 말하는 테이블을 뜻한다.
- 관계 데이터 모델에서 릴레이션은 제목과 본체의 쌍으로 구성된다.
  - 제목은 임의의 개수로 구성된 속성의 집합이다. 속성은 이름과 데이터형의 쌍으로 되어 있다.
  - 본체는 속성값의 집합인 튜플(레코드)의 집합이다.

## 4.4 가역성

### UNDO 가능한 선택을 하라

- 가역이란 어떤 변화가 발생해도 특정 조건을 가하면 원래 상태로 돌아오는 성질이다.
- 실세계의 상황은 항상 변화하므로 실세계의 영향을 받는 소프트웨어 입장에서는 유연하고 적응력이 있는 가역적인 코드를 작성해 두어야 한다.

### 최종 결정 따위는 없다

- 하나의 사실에 깊게 종속되면 그곳에 변경이 생겼을 때 해당 코드는 파탄이 난다.

### 특정 기술에 종속되지 않는다

- 변경에 견디기 위해 초기화가 가능한 설계를 해둔다.
  - 코드에 유연성을 갖도록 하는 것이 중요하다.
- 위험 발생 시의 충격이나 위험 발생 확률 등을 고려해서 되돌아올 수 있는 설계와 단순한 설계 사이에서 균형을 취하도록 한다.

### 아키텍처의 가역성

- 코드를 작성할 때는 유연한 설계를 계속 유지하도록 노력하는 것이 가장 중요하다.
- 아키텍처 설계 시점에 가역성을 고려할 필요가 있다.

## 4.5 코드의 구린내

### 코드의 위험 신호를 무시하지 마라

- 코드의 구린내란 코드 중에서 이해하기 어렵고, 수정하기 어렵고, 확장하기 어렵다고 느껴지는 부분을 뜻한다.

### 후각은 리팩토링의 필요조건

- 리팩토링이란 외부에서 보는 코드의 동작을 바꾸지 않고 코드 내부의 구조를 개선하는 기법이다.
- 깨끗한 코드는 읽기 편하고, 수정하기 편하고 디버깅하기 편하다.
- 지저분한 코드는 모든 것이 난관이다.
- 리팩토링을 통해 기존 코드를 개선하려면 어떤 코드를 개선해야 좋을지를 판단할 수 있어야 한다.

### 구린내의 경향을 이해한다

#### 자주 보인다

- 똑같은 코드가 여기저기 흩어져 있는 상태다.
- 중복된 코드는 수정하기 어려워진다.
  - 오류를 찾아내어 수정할 때 여러 군데를 수정해야 하기 때문이다.
- 중복된 코드는 하나의 함수로 모아 두도록 한다.

#### 너무 길다

- 함수가 너무 길어 스크롤을 몇 번이나 내려도 끝나지 않는 상태다.
- 함수가 너무 길면 이해하기 어려워진다.
- 함수가 너무 길면 분할해서 짧게 만든다.

#### 너무 크다

- 모듈이 너무 커서 관리 불능인 상태다.
- 모듈이 너무 크다는 말은 해당 모듈이 담당하는 역할이 너무 크다는 뜻이다.
- 모듈이 너무 크면 분해해서 작게 만든다.

#### 너무 많다

- 모듈이 너무 많아서 관리 불능인 상태다.
- 모듈이 크다는 이유로 지나치게 분해해서는 안된다.
  - 너무 분해하면 모듈이 너무 많아져 반대로 관리 불능 상태가 되기 때문이다.
- 모듈이 너무 많으면 별 작업을 하지 않는 중개 모듈을 삭제하거나 통폐합해서 수를 줄인다.

#### 이름이 맞지 않는다

- 이름과 실제 코드가 맞지 않는 상태다.
- 각각의 이름에는 코드를 읽는 사람에게 적절한 정보를 전해주는 역할이 있다.
- 표현하고 싶은 개념과 이름이 맞지 않는 코드를 발견하면 즉시 적절한 이름으로 변경한다.

## 4.6 기술적 부채

### 문제 있는 코드는 빚이다

- 프로그래밍에는 2가지 길이 있다.
  - 시간이 좀 걸리더라도 깨끗한 코드를 작성하는 길
  - 신속하지만 지저분한 코드를 작성하는 길
- 지저분한 코드를 선택한다면 소프트웨어는 이른바 부채를 떠안는 셈인데, 이를 기술적 부채라고 한다.
- 기술적 부채는 코드에서 수정하기 어렵고 이해하기 어려운, 문제 있는 지저분한 코드 부분을 뜻한다.
- 일시적으로 지저분한 코드를 허용했어도 시간을 두지 않고 바로 변제하면 문제가 되지는 않는다.
  - 변제란 변경 전으로 되돌아가 시간이 충분히 있었다면 수행했을 올바른 방법, 즉 깨끗한 코드로 수정하는 것을 의미한다.
- 곧장 변제하지 못하면 이자가 발생하며, 더 이상 사용자에게 가치를 제공할 수 없다.

### 문제 있는 코드를 제대로 대하는 방법

- 기술적 부채는 악순환을 낳는다.
- 코드를 이해하기 어려우면 기능을 추가하는 데 시간이 걸린다.
- 시간이 걸린다는 말은 보이지 않는 곳에서 아직 변제가 끝나지 않은 부채가 늘어난다는 뜻이다.
- 소프트웨어 개발에서 시간을 차용한다는 개념은, 해야 할 일을 어떻게든 완수해 내면서 위험 요소가 있는 마일스톤을 달성하는 데 도움이 되는 전략이다.
  - 그 시점에서 완벽한 코드를 작성하기는 힘들더라도, 약간의 절차를 생략하고 최소한의 완료 기준을 충족하는 코드라면 작성할 수 있을지도 모른다.
- 부채를 변제하지 않고있으면 머지않아 막다른 곳에 몰리며, 기술적 부채라는 개념을 도입해 이런 부채를 제어해 가야 한다.

### 문제 있는 코드를 관리한다

- 프로그래밍에 기술적 부채 개념을 도입해 문제 있는 코드를 관리한다.
- 기술적 부채는 신속하게 갚는 것이 무엇보다 중요한 대책이다.
- 만약 변제할 시간이 없다면 적어도 본래 작성했어야 할 코드 설계를 문서에라도 남겨둔다.

### 코드를 깨끗이 만드는 의의를 설명

- 기술적 부채라는 비유는 코드에 정통하지 않은 사람에게 코드를 깨끗이 만들어 두는 활동의 의미와 이를 위해 필요한 시간의 의미를 이해시키는 재료가 된다.
- 코드를 깨끗이 만들 필요성은 코드를 작성하고 보수해 본 사람이 아니면 실감하기 어려운 법이다.

### 문제 있는 코드의 원인

- 경험이 부족한 프로그래머
- 전문화된 코드
- 마감 압박
- 불필요하게 복잡한 코드
- 읽기 어려운 코드
- 그냥 나쁜 설계
