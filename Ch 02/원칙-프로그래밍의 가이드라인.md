# Chapter 2 원칙-프로그래밍의 가이드라인

## 2.1 KISS - Keep It Simple, Stupid / Keep It Short and Simple

### 코드는 단순하게 유지한다

- 코드를 작성할 때 최우선 가치를 단순성과 간결성에 둔다.
- 오류 작성이나 기능 확장할 때도 항상 복잡해지지 않도록 의도적으로 코드를 단순하게 유지한다.

### 코드는 무질서로 향한다

- 복잡한 코드는 읽기 어렵고 수정하기 어려워진다.
- 단순한 코드는 읽기 쉽고 이해하기 쉬우며 수정이 용이하다.

### 코드에 불필요한 것을 하지 않는다

- 코드에서 불필요한 것과 넘치는 것을 가능한 한 제거해야 하며, 이를 위해 가장 간단한 방법은 무엇인지 항상 질문을 던져야 한다.

### KISS의 적용 범위

- KISS는 엔지니어링 전반에 적용되는 원칙이다.
- 요구사항에 대해 비교적 유연하게 대응할 수 있다고 생각하는 것이 하나의 요인이다.

### less is more

- 단순한 것이 더 아름답다.
- 불필요한 코드를 작성하지 않음으로써 코드를 단순하게 유지하고 갖가지 문제를 미리 회피할 수 있다.

### 오컴의 면도날

- 오컴의 면도날이란 어떤 사항을 설명하는 데 필요 이상으로 많은 전제를 가정해서는 안된다는 사고방식이다.
- 가장 단순한 방식이 옳다는 뜻이다.

## 2.2 DRY - Don't Repeat Yourself

### 코드 복사는 금물

- 똑같은 코드를 중복해서 작성해서는 안된다.
- 로직을 복붙할 경우, 같은 로직이 여러 군데로 흩어진다.
- 제어문 블록도 여러 군데 중복해서 나타날 때도 있다.
- 정수 리터럴을 직접 코드에 내장하는 것도 코드 중복에 해당한다.
  - 정수가 가리키는 정보가 중복해서 존재하기 때문이다.

### 코드를 개선할 수 없다

- 코드 중복이 있으면 다음과 같은 어려움이 있다.

1. 코드를 읽는 작업이 어려워진다.
2. 코드를 수정하는 작업이 어려워진다.
3. 테스트가 없다.

### 코드를 추상화한다

- 처리하는 코드를 묶고 이름을 붙여 함수화, 모듈화하고, 데이터라면 이름을 붙여 상수를 정의한다.
- 추상화 장점
  - 코드의 양이 줄어 읽는 양을 줄일 수 있다.
  - 로직이나 데이터에 이름이 붙었으므로 코드가 읽기 쉬워진다.
  - 똑같은 코드가 한 군데에 집약되어 있어서 한 군데만 수정하면 되므로 코드를 수정하기 쉽고, 품질을 담보하기 쉬워진다.
  - 추상화한 부분은 재사용하기 쉬워진다. 새로운 기능을 추가할 때 코드를 재사용하면 더욱 빠르고 품질 좋게 프로그래밍을 완료할 수 있다.

### DRY의 적용 범위

- DRY는 소프트웨어 개발에 관한 모든 활동에 적용할 수 있다.
- 구체적으로는 반복되는 작업을 자동화해야 한다.
  - 대표적인 작업으로 지속적인 통합이라는 테스트/빌드/배포 작업이 있다.

### DRY와 프로그래밍 기술

- 프로그래밍 기술의 대부분은 코드 중복을 제거하는 것을 목적 중 하나로 삼고 있다.
- 객체 지향도 중복 제거를 위한 기법이 내재되어 있으며, 디자인 패턴도 코드를 재사용 가능하게 하려고 구조 패턴을 제공한다.

### 불가피한 DRY 위반

- 소프트웨어 개발에서는 어느 정도 불가피한 중복도 존재한다.
- 대표적인 사례로 객체지향 프로그래밍의 클래스와 관계형 데이터베이스의 테이블이다.
  - 관계형 데이터베이스 쪽에 테이블 정의, 코드 쪽에 테이블 매핑 설정 파일, 소스 파일 이렇게 세 군데에 같은 정보를 갖고 있어야 한다.

### WET

- DRY와 대비되는 개념으로 Write Every Time 또는 Write Everything Twice의 약아로 같은 것을 반복한다는 의미이다.
- DRY가 되어 있지 않은 코드에 대해 비꼬는 표현으로 사용한다.

### One Fact in One Place(OFOP)

- 한 곳에는 하나의 사실이라는 의미로 데이터베이스 논리 설계에서 테이블 설계의 핵심이 되는 원칙이다.
- OFOP는 데이터베이스에 저장되는 데이터의 중복을 금지한다.

### Once and Only Once(OAOO)

- 한 번만, 단 한 번만이라는 의미이다.
- DRY와 의미나 목적은 동일하나, 적용 범위가 좁고 프로그래밍 컨덱스트에서만 사용된다.

### 레거시 코드

- 최근 레거시 코드는 테스트가 없는 코드라고 재정의되었다.
- 중복 코드는 대부분 테스트가 없다.
- 테스트 없이 코드를 변경하는 작업은 위험하며, 품질을 지키는데 있어 반드시 필요한 절차이다.

## 2.3 YAGNI - You Aren't Going to Need it

### 코드를 필요할 때 최소한으로

- 코드를 '아마 필요하겠지', '필요해질지도 몰라' 같은 식으로 작성해서는 안 된다.
- 필요한 코드만을 작성한다는 방침으로 프로그래밍에 임해야 한다.

### 코드의 예측은 빗나간다

- 여러 가지 사태에 대비해 코드를 넣어 두더라도 결국 이용되지 않는 것이 대부분이다.
- 확장성을 염두에 두면 오히려 코드에 불필요한 복잡성을 담는 셈이 된다.

### 코드는 지금 필요한 것만

- 범용성보다는 단순성을 생각하는 것이 좋다.
- 범용성이 가져다주는 재사용성이나 확장성도 좋지만, 그보다는 우선 사용할 수 있는 데 가치를 두는 것이 좋다.

### DTSTTCPW

- Do The Simplest Thing That Could Possibly Work의 약어로 효과가 있는 방법 중에서 가장 간단한 방법으로 하라라는 의미이다.
- 나중을 생각해서 프로그래밍하면 코드의 복잡성이 증가하고 변경 비용이 급상승한다.

## 2.4 PIE - Program Intently and Expressively

### 코드의 의도를 전한다

- 코드는 사람이 읽기 위한 것이다.
- 코드를 작성할 때 의도를 명확하게 표현해야 한다.

### 코드가 유일한 실마리

- 소프트웨어 개발 중에는 다양한 문서가 작성되지만, 문서들만으로는 소프트웨어가 어떻게 동작하는지에 관해 정확하게 알 수 없다.

### 코드는 읽기 쉬운 것이 최우선

- 코드를 작성할 때는 작성하기 쉬움보다 읽기 쉬움을 중시한다.
- 읽기 쉽다면 작성할 때의 효율은 다소 떨어질지언정 거기에 상응하는 가치가 있으며, 나중에 실행 효율을 높이기는 간단하다.

### 두더지 잡기식 개발을 피한다

- 읽기 쉽고 오류가 없으며 품질이 좋은 코드를 작성하려면 분명히 시간이 걸린다.
- 단기적으로 손실로 보이지만, 두더지 잡기식 개발이 되지 않으므로 장기적으로 반드시 이익을 가져다준다.

### 주석을 작성한다

- 코드는 what과 how 밖에 표현하지 못한다.
- 어째서 그것을 하는지를 표현하려면 주석을 사용할 필요가 있다.

### 문학적 프로그래밍

- 문학적 프로그래밍은 코드 자체를 문서화하는 기법이다.
  - 여기서 문서는 프로그래밍되어 있는 것이 무엇인지 기술하는 설명이면서 동시에 컴파일해서 실행하는 소프트웨어다.
- 질 높고 양적으로도 풍부한 설명 정보를 직접 참조할 수 있으므로 일반 코드보다 유지보수가 매우 쉬워진다.

## 2.5 SLAP - Single Level of Abstraction Principle

### 코드 수준을 맞춘다

- 높은 수준의 추상화 개념(고수준)과 낮은 수준의 추상화 개념(저수준)을 분리하도록 한다.
- 코드의 추상화 수준을 일치시키면 훌륭한 책처럼 읽을 수 있다.

```javascript
function 고수준() { // 수준1의 목차
    중수준1();
    중수준2();
}

function 중수준1() { // 수준2의 목차 - 1
    저수준1();
    저수준2();
}

function 저수준1() { // 본문 내용
    // 처리
}

function 저수준2() { // 본문 내용
    // 처리
}

function 중수준2() { // 수준2의 목차 - 2
    저수준3();
}

function 저수준3() { // 본문 내용
    // 처리
}
```

### 코드에 요약성과 열람성을 가져다준다

- 코드가 수준이 일치된 함수로 분할되어 있으면 요약성과 열람성을 동시에 충족한다.

### 함수를 구조화한다

- 의도가 전달되기 쉽게끔 처리는 추상화 수준을 일치시킨 작은 단계의 함수로 변환한다.
- 다른 함수를 호출하는 코드로 구성된 함수를 복합 함수(composed method)라고 한다.
- 복합 함수 안에서는 추상화 수준이 다른 함수를 호출하지 않도록 한다.
  - 하나의 함수 안에서 어떤 부분에서는 데이터베이스 연결처럼 낮은 수준의 처리를 수행하고, 다른 부분에서는 비즈니스 로직처럼 높은 수준의 처리를 수행하는, 수준이 불일치된 코드를 작성해서는 안된다.

### SLAP의 적용 범위

- 훌륭한 소프트웨어 설계에서는 개념이 여러 수준으로 분리되어 각기 다른 저장소에 저장된다.

### SLAP의 순서

- 훌륭한 글을 쓸 때 핵심은 "내용을 쓰는 것"과 "내용을 이해하기 쉽게 전하기 위한 구성을 생각하는 것"을 별개로 작업하는 데 있다.
  - 코드도 구체적인 처리를 작성하는 작업과 추상화 수준을 일치시키는 작업은 모드를 전환해서 별개의 작업으로 수행하도록 한다.

### 코드와 책의 유사성

- 서문
  - 파일 첫머리의 주석에 해당
- 목차
  - 함수의 일람에 해당
- 섹션
  - 하나의 파일에 여러 모듈이 기술되어 있거나, 파일 안의 함수를 논리적으로 몇 개의 그룹으로 분류할 수 있다면 여러 개의 큰 섹션으로 분할할 수 있음
- 장
  - 함수에 해당
- 단락
  - 함수 안에서 코드의 블록에 해당
- 문장
  - 코드 하나하나의 구문에 해당
- 상호 참조 및 색인
  - 코드에서 작성할 필요는 없음
  - 통합 개발 환경이나 편집기의 건너뛰기 기능, 검색 기능이 담당하는 영역

## 2.6 OCP - Open-Closed Principle

### 코드의 변경은 파급시키지 않는다

- 코드는 확장에 대해서 열려 있고 수정에 대해서 닫혀 있는 2가지 속성을 동시에 충족하도록 설계한다.
  - 확장에 대해서 열려 있다는 말은 코드의 동작을 확장할 수 있다는 의미다.
  - 수정에 대해서 닫혀 있다는 말은 코드의 동작을 확장하더라도 그 밖의 코드는 전혀 영향을 받지 않는다는 의미다.

### 코드의 변경에 유연하게 대응한다

- 어떤 소프트웨어든 계속 살아 있는 한 변화한다.
  - 따라서 변경에 대해 유연하게 대응할 수 있는 유연한 설계가 요구된다.

### 코드에 인터페이스를 사용한다

- 특정 기능을 가진 모듈을 설계할 때, 모듈의 사용자인 클라이언트가 모듈의 제공자인 서버를 직접 호출하는 방식은 경직된 설계다.
  - 다른 서버를 사용하고 싶다면 클라이언트를 변경해야 하기 때문이다.

### OCP의 적용 범위

- 코드의 모든 부분에 OCP를 적용하는 것은 과한 방식이다.
- OCP의 과도한 적용을 방지하려면 변경 내용을 지나치게 예측하지 말아야 한다.
- OCP 적용의 핵심은 변경 내용을 예측하기보다 변화할 법한 부분을 예측하는 데 있다.

### OCP의 구현과 설계

- OCP를 구현하는 방법 가운데 대표적인 기술이 객체지향의 다형성이다.

### 변경 보호

- GRASP(General Responsibility Assignment Software Pattern)라는 책임 주도 개발 설계기법이 있는데, 여기에 변경 보호(protected variations)라는 설계 패턴이 소개되어 있다.
  - 변경 예측되는 불안정한 부분과의 접점을 식별해서 접점 주변에 안정된 인터페이스를 구축하는 식으로 책임을 할당하는 기법이다.

## 2.7 명명이 중요하다

### 코드에서 명명은 가장 중요한 과제

- 이름을 붙이는 행위
  - 적절한 이름을 붙일 수 있었다는 것은 해당 요소가 바르게 이해되고 바르게 설계되어 있다는 뜻이다.
- 이름 자체
  - 이름은 코드를 통해 프로그래머끼리 의사소통하기 위한 최대의 터전이다.

### 코드를 읽는 사람에 대한 사용자 인터페이스

- 이름은 코드를 읽는 사람에 대한 UI다.
- 읽으면 곧바로 의미를 알 수 있는 것이 좋은 이름이다.
- 좋은 이름의 장점
  - 코드를 읽을 때 함수 이름만 봐도 이후의 처리 개요를 파악할 수 있으므로 적절히 건너뛰면서 읽을 수 있다.
  - 코드를 작성할 때 해당 함수를 사용하는 곳에서는 이름이 가이드가 되어 목적이나 사용 방법을 바로 이해할 수 있으므로 호출이 간단하다. 작성이 끝난 코드는 좋은 이름 덕분에 설명적이라 읽기 쉬워진다.
- 나쁜 이름의 단점
  - 코드를 읽을 때 함수 이름만 보고 처리 내용을 알 수 없다면 내용을 이해하기 위해 함수 내부를 해석해야만 한다. 함수 계층이 얕다면 그다지 문제가 되지 않겠지만, 계층이 깊어질수록 프로그래머에게는 부담이 된다.
  - 코드를 작성할 때 사용하고 싶은 함수의 이름으로부터 여러 가지 판단을 내릴 수 없다면 역시 함수 내부를 분석할 필요가 생긴다.

### 코드는 우선 이름을 정한다

- 명명시 주의사항
  - 이름에는 더욱 많은 정보를 담도록 한다.
  - 이름은 오해받지 않도록 주의한다.
  - 이름이 효과와 목적을 설명하도록 한다.
  - 이름은 발음 가능한 것으로 한다.
  - 이름은 검색 가능하도록 붙인다.

### 마인드 매핑 회피

- 코드를 읽는 사람이 이름을 보고 마음속에서 자기가 기존에 알고 있던 이름으로 변환해야 하는, 즉 마인드 매핑해야 하는 상황은 최대한 피해야 한다.

### 루프백 확인

- 이름이란 명명의 기반이 된 내용의 설명문을 복원할 수 있어야 한다.
- 내용의 설명문으로부터 이름을 떠올렸다면, 반대로 이름에서 추측할 수 있는 설명문을 생각해 보는 것이다.
