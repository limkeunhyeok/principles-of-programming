# Chapter 2 원칙-프로그래밍의 가이드라인

## 2.4 PIE - Program Intently and Expressively

### 코드의 의도를 전한다

- 코드는 사람이 읽기 위한 것이다.
- 코드를 작성할 때 의도를 명확하게 표현해야 한다.

### 코드가 유일한 실마리

- 소프트웨어 개발 중에는 다양한 문서가 작성되지만, 문서들만으로는 소프트웨어가 어떻게 동작하는지에 관해 정확하게 알 수 없다.

### 코드는 읽기 쉬운 것이 최우선

- 코드를 작성할 때는 작성하기 쉬움보다 읽기 쉬움을 중시한다.
- 읽기 쉽다면 작성할 때의 효율은 다소 떨어질지언정 거기에 상응하는 가치가 있으며, 나중에 실행 효율을 높이기는 간단하다.

### 두더지 잡기식 개발을 피한다

- 읽기 쉽고 오류가 없으며 품질이 좋은 코드를 작성하려면 분명히 시간이 걸린다.
- 단기적으로 손실로 보이지만, 두더지 잡기식 개발이 되지 않으므로 장기적으로 반드시 이익을 가져다준다.

### 주석을 작성한다

- 코드는 what과 how 밖에 표현하지 못한다.
- 어째서 그것을 하는지를 표현하려면 주석을 사용할 필요가 있다.

### 문학적 프로그래밍

- 문학적 프로그래밍은 코드 자체를 문서화하는 기법이다.
  - 여기서 문서는 프로그래밍되어 있는 것이 무엇인지 기술하는 설명이면서 동시에 컴파일해서 실행하는 소프트웨어다.
- 질 높고 양적으로도 풍부한 설명 정보를 직접 참조할 수 있으므로 일반 코드보다 유지보수가 매우 쉬워진다.

## 2.5 SLAP - Single Level of Abstraction Principle

### 코드 수준을 맞춘다

- 높은 수준의 추상화 개념(고수준)과 낮은 수준의 추상화 개념(저수준)을 분리하도록 한다.
- 코드의 추상화 수준을 일치시키면 훌륭한 책처럼 읽을 수 있다.

```javascript
function 고수준() { // 수준1의 목차
    중수준1();
    중수준2();
}

function 중수준1() { // 수준2의 목차 - 1
    저수준1();
    저수준2();
}

function 저수준1() { // 본문 내용
    // 처리
}

function 저수준2() { // 본문 내용
    // 처리
}

function 중수준2() { // 수준2의 목차 - 2
    저수준3();
}

function 저수준3() { // 본문 내용
    // 처리
}
```

### 코드에 요약성과 열람성을 가져다준다

- 코드가 수준이 일치된 함수로 분할되어 있으면 요약성과 열람성을 동시에 충족한다.

### 함수를 구조화한다

- 의도가 전달되기 쉽게끔 처리는 추상화 수준을 일치시킨 작은 단계의 함수로 변환한다.
- 다른 함수를 호출하는 코드로 구성된 함수를 복합 함수(composed method)라고 한다.
- 복합 함수 안에서는 추상화 수준이 다른 함수를 호출하지 않도록 한다.
  - 하나의 함수 안에서 어떤 부분에서는 데이터베이스 연결처럼 낮은 수준의 처리를 수행하고, 다른 부분에서는 비즈니스 로직처럼 높은 수준의 처리를 수행하는, 수준이 불일치된 코드를 작성해서는 안된다.

### SLAP의 적용 범위

- 훌륭한 소프트웨어 설계에서는 개념이 여러 수준으로 분리되어 각기 다른 저장소에 저장된다.

### SLAP의 순서

- 훌륭한 글을 쓸 때 핵심은 "내용을 쓰는 것"과 "내용을 이해하기 쉽게 전하기 위한 구성을 생각하는 것"을 별개로 작업하는 데 있다.
  - 코드도 구체적인 처리를 작성하는 작업과 추상화 수준을 일치시키는 작업은 모드를 전환해서 별개의 작업으로 수행하도록 한다.

### 코드와 책의 유사성

- 서문
  - 파일 첫머리의 주석에 해당
- 목차
  - 함수의 일람에 해당
- 섹션
  - 하나의 파일에 여러 모듈이 기술되어 있거나, 파일 안의 함수를 논리적으로 몇 개의 그룹으로 분류할 수 있다면 여러 개의 큰 섹션으로 분할할 수 있음
- 장
  - 함수에 해당
- 단락
  - 함수 안에서 코드의 블록에 해당
- 문장
  - 코드 하나하나의 구문에 해당
- 상호 참조 및 색인
  - 코드에서 작성할 필요는 없음
  - 통합 개발 환경이나 편집기의 건너뛰기 기능, 검색 기능이 담당하는 영역

## 2.6 OCP - Open-Closed Principle

### 코드의 변경은 파급시키지 않는다

- 코드는 확장에 대해서 열려 있고 수정에 대해서 닫혀 있는 2가지 속성을 동시에 충족하도록 설계한다.
  - 확장에 대해서 열려 있다는 말은 코드의 동작을 확장할 수 있다는 의미다.
  - 수정에 대해서 닫혀 있다는 말은 코드의 동작을 확장하더라도 그 밖의 코드는 전혀 영향을 받지 않는다는 의미다.

### 코드의 변경에 유연하게 대응한다

- 어떤 소프트웨어든 계속 살아 있는 한 변화한다.
  - 따라서 변경에 대해 유연하게 대응할 수 있는 유연한 설계가 요구된다.

### 코드에 인터페이스를 사용한다

- 특정 기능을 가진 모듈을 설계할 때, 모듈의 사용자인 클라이언트가 모듈의 제공자인 서버를 직접 호출하는 방식은 경직된 설계다.
  - 다른 서버를 사용하고 싶다면 클라이언트를 변경해야 하기 때문이다.

### OCP의 적용 범위

- 코드의 모든 부분에 OCP를 적용하는 것은 과한 방식이다.
- OCP의 과도한 적용을 방지하려면 변경 내용을 지나치게 예측하지 말아야 한다.
- OCP 적용의 핵심은 변경 내용을 예측하기보다 변화할 법한 부분을 예측하는 데 있다.

### OCP의 구현과 설계

- OCP를 구현하는 방법 가운데 대표적인 기술이 객체지향의 다형성이다.

### 변경 보호

- GRASP(General Responsibility Assignment Software Pattern)라는 책임 주도 개발 설계기법이 있는데, 여기에 변경 보호(protected variations)라는 설계 패턴이 소개되어 있다.
  - 변경 예측되는 불안정한 부분과의 접점을 식별해서 접점 주변에 안정된 인터페이스를 구축하는 식으로 책임을 할당하는 기법이다.

## 2.7 명명이 중요하다

### 코드에서 명명은 가장 중요한 과제

- 이름을 붙이는 행위
  - 적절한 이름을 붙일 수 있었다는 것은 해당 요소가 바르게 이해되고 바르게 설계되어 있다는 뜻이다.
- 이름 자체
  - 이름은 코드를 통해 프로그래머끼리 의사소통하기 위한 최대의 터전이다.

### 코드를 읽는 사람에 대한 사용자 인터페이스

- 이름은 코드를 읽는 사람에 대한 UI다.
- 읽으면 곧바로 의미를 알 수 있는 것이 좋은 이름이다.
- 좋은 이름의 장점
  - 코드를 읽을 때 함수 이름만 봐도 이후의 처리 개요를 파악할 수 있으므로 적절히 건너뛰면서 읽을 수 있다.
  - 코드를 작성할 때 해당 함수를 사용하는 곳에서는 이름이 가이드가 되어 목적이나 사용 방법을 바로 이해할 수 있으므로 호출이 간단하다. 작성이 끝난 코드는 좋은 이름 덕분에 설명적이라 읽기 쉬워진다.
- 나쁜 이름의 단점
  - 코드를 읽을 때 함수 이름만 보고 처리 내용을 알 수 없다면 내용을 이해하기 위해 함수 내부를 해석해야만 한다. 함수 계층이 얕다면 그다지 문제가 되지 않겠지만, 계층이 깊어질수록 프로그래머에게는 부담이 된다.
  - 코드를 작성할 때 사용하고 싶은 함수의 이름으로부터 여러 가지 판단을 내릴 수 없다면 역시 함수 내부를 분석할 필요가 생긴다.

### 코드는 우선 이름을 정한다

- 명명시 주의사항
  - 이름에는 더욱 많은 정보를 담도록 한다.
  - 이름은 오해받지 않도록 주의한다.
  - 이름이 효과와 목적을 설명하도록 한다.
  - 이름은 발음 가능한 것으로 한다.
  - 이름은 검색 가능하도록 붙인다.

### 마인드 매핑 회피

- 코드를 읽는 사람이 이름을 보고 마음속에서 자기가 기존에 알고 있던 이름으로 변환해야 하는, 즉 마인드 매핑해야 하는 상황은 최대한 피해야 한다.

### 루프백 확인

- 이름이란 명명의 기반이 된 내용의 설명문을 복원할 수 있어야 한다.
- 내용의 설명문으로부터 이름을 떠올렸다면, 반대로 이름에서 추측할 수 있는 설명문을 생각해 보는 것이다.
